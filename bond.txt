9/19/2017

  *YouCanDoThis> parse (char '%' *> hexDigit) "" "%f"
  Right 'f'
  *YouCanDoThis> :info (*>)
  class Functor f => Applicative (f :: * -> *) where
    ...
    (*>) :: f a -> f b -> f b
    ...
          -- Defined in `GHC.Base'
  infixl 4 *>

With our version of Haskell do we need to do the Applicative
thing that Real World Haskell does? Doesn't the version we 
use set all that up? How would we prove this?

  *YouCanDoThis> :t readHex $ []
  readHex $ [] :: (Num a, Eq a) => [(a, String)]
  *YouCanDoThis> :t ($)
  ($) :: (a -> b) -> a -> b
  *YouCanDoThis> -- $ fmap readHex across our list
  *YouCanDoThis> :t fmap
  fmap :: Functor f => (a -> b) -> f a -> f b
  *YouCanDoThis> -- *map* readHex across our list
  *YouCanDoThis> :t readHex $ ['9','a']
  readHex $ ['9','a'] :: (Num a, Eq a) => [(a, String)]
  *YouCanDoThis> readHex $ ['9','a']
  [(154,"")]
  *YouCanDoThis> readHex $ ['9','a','c']
  [(2476,"")]
  *YouCanDoThis> x b = b * 2
  *YouCanDoThis> x $ [1,2]

  <interactive>:64:1: error:
      * Non type-variable argument in the constraint: Num [t]
        (Use FlexibleContexts to permit this)
      * When checking the inferred type
          it :: forall t. (Num [t], Num t) => [t]
  *YouCanDoThis> :t x
  x :: Num a => a -> a
  *YouCanDoThis> x $ [1,2] :: Int

  <interactive>:66:1: error:
      * Couldn't match expected type `Int' with actual type `[t0]'
      * In the expression: x $ [1, 2] :: Int
        In an equation for `it': it = x $ [1, 2] :: Int
  *YouCanDoThis> x $ [1,2] :: Num

  <interactive>:67:14: error:
      * Expecting one more argument to `Num'
        Expected a type, but `Num' has kind `* -> Constraint'
      * In an expression type signature: Num
        In the expression: x $ [1, 2] :: Num
        In an equation for `it': it = x $ [1, 2] :: Num
  *YouCanDoThis> :t [1,2]
  [1,2] :: Num t => [t]
  *YouCanDoThis> x $ [1,2]

  <interactive>:69:1: error:
      * Non type-variable argument in the constraint: Num [t]
        (Use FlexibleContexts to permit this)
      * When checking the inferred type
          it :: forall t. (Num [t], Num t) => [t]
  *YouCanDoThis> x 4
  8
  *YouCanDoThis> fmap x [1,2]
  [2,4]
  *YouCanDoThis> :t readHex $ ['9','a']
  readHex $ ['9','a'] :: (Num a, Eq a) => [(a, String)]
  *YouCanDoThis>

What I'm trying to do is understand the use of $ with readHex. I thought 
it was fmap but really it's just map. But I still don't completely get it. 

9/18/2017

What are our types here: 

p_pair_app1 :: CharParser () (String, Maybe String)
p_pair_app1 = 
    liftM2 (,) (many1 p_char) (optionMaybe (char '=' >> many p_char))

:t many1
many1
  :: Text.Parsec.Prim.Stream s m t =>
     Text.Parsec.Prim.ParsecT s u m a
     -> Text.Parsec.Prim.ParsecT s u m [a]

So the return value of many1 is a Text.Parsec.Prim.ParsecT s u m [a] 
how the F do we extract [a] out of that for our LiftM2 (,) operation?

:t p_char 
p_char :: CharParser () Char

ok, so the return value of p_char falls into the types for ParsecT. 

I wonder if there's a thing with Monad Transformers where when we run
them under Monad operations we "just" get a "certain" monad within the 
stack of monads in the transformer. 

*YouCanDoThis> :t optionMaybe
optionMaybe
  :: Text.Parsec.Prim.Stream s m t =>
     Text.Parsec.Prim.ParsecT s u m a
     -> Text.Parsec.Prim.ParsecT s u m (Maybe a)

So optionMaybe is just a function which accepts a parser and possibly 
returns the Nothing rather than failure. 

Back to liftM2, so it's lifting *by* an operation. An operation is a thing
like (+) or in our case (,). So depending on the incoming monad (list, Maybe
or whatever) we apply our arguments *left to right* to (,)

9/15/2017

Reading this: https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html
I ran into 'go' which led me to this: 
https://stackoverflow.com/questions/5844653/haskell-why-the-convention-to-name-a-helper-function-go
who pointed me to this: 
http://book.realworldhaskell.org/read/profiling-and-optimization.html#id678845

moral of the story: keep reading rwh and profile profile profile! 

Using the applicative p_pair: 

  [1 of 1] Compiling YouCanDoThis     ( C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\queryString.hs, interpreted )
  Ok, modules loaded: YouCanDoThis.
  Loaded GHCi configuration from C:\Users\brodyb\AppData\Local\Temp\ghci8648\ghci-script
  *YouCanDoThis> :l queryString.hs
  [1 of 1] Compiling YouCanDoThis     ( queryString.hs, interpreted )
  Ok, modules loaded: YouCanDoThis.
  *YouCanDoThis> :browse
  p_query :: CharParser () [(String, Maybe String)]
  p_pair :: CharParser () (String, Maybe String)
  p_pair_app1 :: CharParser () (String, Maybe String)
  urlBaseChars :: [Char]
  p_char :: CharParser () Char
  p_ha :: CharParser () Char
  p_hab :: CharParser () (Char, Char)
  p_hex :: CharParser () Char
  *YouCanDoThis> :info p_pair_app1
  p_pair_app1 :: CharParser () (String, Maybe String)
          -- Defined at queryString.hs:19:1
  *YouCanDoThis> parseTest p_pair_app1 "a=b"
  ("a",Just "b")
  *YouCanDoThis> parseTest p_pair_app1 "a%21=b+c"
  ("a!",Just "b c")
  *YouCanDoThis> :info ap

  <interactive>:1:1: error: Not in scope: `ap'
  *YouCanDoThis> :import Control.Applicative
  unknown command ':import'
  use :? for help.
  *YouCanDoThis> :module Control.Applicative
  Prelude Control.Applicative> :info ap

  <interactive>:1:1: error: Not in scope: `ap'
  Prelude Control.Applicative> :module Control.Monad
  Prelude Control.Monad> :info ap
  ap :: Monad m => m (a -> b) -> m a -> m b       -- Defined in `GHC.Base'
  Prelude Control.Monad> :info mplus
  class (GHC.Base.Alternative m, Monad m) =>
        MonadPlus (m :: * -> *) where
    ...
    mplus :: m a -> m a -> m a
          -- Defined in `GHC.Base'
  Prelude Control.Monad> :info mplus
  class (GHC.Base.Alternative m, Monad m) =>
        MonadPlus (m :: * -> *) where
    ...
    mplus :: m a -> m a -> m a
          -- Defined in `GHC.Base'

9/12/2017

Ok, so what *is* a bond file?
a namespace
followed by (zero?) or more
  - struct
  - using
  - enum
  - service

struct:
  - struct
  - space
  - Identifier
  - Zero or more of: 
    - Angle Brackets
    - capture Identifier
  - If this struct is generic
    - space
    - colon
    - Identifier
  - OR
  - Zero or one of:  
    - space
    - colon
    - Identifier
    - Zero or one of:
      - Angle Brackets
  - ; 
  - OR
  - left curly brace
  - zero or more of
    - int (strictly increasing?)
    - colon
    - space
    - TypeThingy
    - Identifier (of existing)
      - Zero or more of
        - Angle Brackets  
      - space
      - Name
      - Zero or more of
        - space
        - equal
        - Identifier
      - semi-colon
  - right curly brace

TypeThingy: 
  - refer to existing type
  - keyword: ex. nullable

using: 
  - using
  - space
  - Identifier
  - Angle Brackets
  - space
  - equal
  - Identifier that was in the Angle Brackets
  - semi-colon

- Should Identifier include the
  notion of possibly having angle brackets?
- So Identifier would return the name
  and an Option for generic?

Angle Brackets: 
  - Left
  - Identifier (of existing thing?!)
  - Right

Identifier:
  - Capital letters
  - zero or more letters
  - ends with non-letter
  * the letters must refer to create something real
    * primitives: ex. string
    * T creating something real in struct Node<T>
    * 0: nullable<Node<T> referring to something real in 

Name: 
  - any letter 
  - any alpha-numeric
  - ends with non-alphanumeric

What we should do: 
- finish reading about parsing with Applicative Functors
- get comfortable with the Applicative style
- continue parsing real examples from bond files
- build a parser that can parse the things
- but how do we traverse what we parsed?

Getting toEnum to work: 

  *YouCanDoThis> :t toEnum
  toEnum :: Enum a => Int -> a
  *YouCanDoThis> toEnum 5
  *** Exception: Prelude.Enum.().toEnum: bad argument
  *YouCanDoThis> :info toEnum
  class Enum a where
    ...
    toEnum :: Int -> a
    ...
          -- Defined in `GHC.Enum'
  *YouCanDoThis> :t 5
  5 :: Num t => t
  *YouCanDoThis> toEnum (5::Int)
  *** Exception: Prelude.Enum.().toEnum: bad argument
  *YouCanDoThis> :t (5::Int)
  (5::Int) :: Int
  *YouCanDoThis> toEnum True

  <interactive>:10:8: error:
      * Couldn't match expected type `Int' with actual type `Bool'
      * In the first argument of `toEnum', namely `True'
        In the expression: toEnum True
        In an equation for `it': it = toEnum True
  *YouCanDoThis> toEnum 1
  *** Exception: Prelude.Enum.().toEnum: bad argument
  *YouCanDoThis> (toEnum 1)::String

  <interactive>:12:2: error:
      * No instance for (Enum String) arising from a use of `toEnum'
      * In the expression: (toEnum 1) :: String
        In an equation for `it': it = (toEnum 1) :: String
  *YouCanDoThis> (toEnum 1)::Bool
  True
  *YouCanDoThis> (toEnum 1)::Int
  1
  *YouCanDoThis> (toEnum 5)::Int
  5

9/9/2017

Wrote my first pair of combinators that do a thing! 

Since the first line of a bond file is a namespace declaration 
I wrote a thing that concieves of a namespace as blocks of 
letters separated by dots. It works! Example: 

Prelude> :l parseBond.hs
[1 of 1] Compiling YouCanDoThis     ( parseBond.hs, interpreted )
Ok, modules loaded: YouCanDoThis.
*YouCanDoThis> parse namespace "(unknown)" "foo.bar"
Right ["foo","bar"]

This is a huge moment because it's a couple of combinators
rather than a monolithic thing in a monad, and it's my thing
rather than from the book AND it has bugs :-) the bugs are that
if you pass it non-letters the parser will return empty strings
which is confusing to me at this point. But hells yes! 

9/8/2017

I read a whole file!

https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html

We need to somehow figure out that using all these primitive 
combinators is using an entire parser as a whole

I say that because I can't get simple stuff to work: 

Prelude>import Text.ParserCombinators.Parsec
Prelude Text.ParserCombinators.Parsec> char ';'

<interactive>:16:1: error:
    * Non type-variable argument
        in the constraint: Text.Parsec.Prim.Stream s m Char
      (Use FlexibleContexts to permit this)
    * When checking the inferred type
        it :: forall (m :: * -> *) u s.
              Text.Parsec.Prim.Stream s m Char =>
              Text.Parsec.Prim.ParsecT s u m Char
Prelude Text.ParserCombinators.Parsec> semicolon = char ';'

also fails: 

Prelude Text.ParserCombinators.Parsec> let semicolon = char ';'

<interactive>:18:5: error:
    * Non type-variable argument
        in the constraint: Text.Parsec.Prim.Stream s m Char
      (Use FlexibleContexts to permit this)
    * When checking the inferred type
        semicolon :: forall (m :: * -> *) u s.
                     Text.Parsec.Prim.Stream s m Char =>
                     Text.Parsec.Prim.ParsecT s u m Char

do our (really real-world haskell's) eol and Text.Parsec.Char string have the 
same signature? If they do, then we should be able to run them through 'parse'
if not.. then think of what next. How would we characterize (pun) the difference?

Totally different, eol is a parser, string is a ...

Prelude Text.ParserCombinators.Parsec> :l parseBond.hs
[1 of 1] Compiling YouCanDoThis     ( parseBond.hs, interpreted )
Ok, modules loaded: YouCanDoThis.
*YouCanDoThis Text.ParserCombinators.Parsec> :browse YouCanDoThis
eol :: GenParser Char st Char
*YouCanDoThis Text.ParserCombinators.Parsec> :t eol
eol :: GenParser Char st Char
*YouCanDoThis Text.ParserCombinators.Parsec> parse eol "(unknown)" "\n"
Right '\n'

*YouCanDoThis Text.ParserCombinators.Parsec> :t string
string
  :: Text.Parsec.Prim.Stream s m Char =>
     String -> Text.Parsec.Prim.ParsecT s u m String
*YouCanDoThis Text.ParserCombinators.Parsec> :t endBy
endBy
  :: Text.Parsec.Prim.Stream s m t =>
     Text.Parsec.Prim.ParsecT s u m a
     -> Text.Parsec.Prim.ParsecT s u m sep
     -> Text.Parsec.Prim.ParsecT s u m [a]

So look: eol and what RWH has us writing feels "one level higher" than the things
in Parsec. eol etc are GenParsers while string etc are functions on ParsecT. 

string signature looks like: ParsecT -> ParsecT -> ParsecT but the items within the ParsecT
are different: s u m a -> s u m sep -> s u m [a]

so INSIDE of a GenParser we can use the primitives. so what makes a GenParser? 
something about using a primitive?

*YouCanDoThis Text.ParserCombinators.Parsec> :info GenParser
type GenParser tok st = Text.Parsec.Prim.Parsec [tok] st :: * -> *
        -- Defined in `Text.Parsec.String'

  I read this as: there's a type called GenParser constructed with a list of tokens (anything)
  and an st, whatever that is and is then realized as a one argument to one argument function. 

  so if you :t a thing we've GenParser you'd ... see * -> * somehow?
  also: how is it that my reading of GenParser says the ctor takes two values when
  the code from RWH clearly passes in three things?

https://hackage.haskell.org/package/parsec-3.1.11/docs/src/Text.Parsec.String.html#Parser

that shows that Text.Parsec.String gives us

   type Parser = Parsec String ()

   which I describe as "A Parsec whose Stream argument is a String, and whose 
   user state type is nothing." BUT THIS IS SOMEHOW CURRIED AT THE TYPE LEVEL and 
   so Parser is left with free type variables that we fill ... 

   eol :: GenParser Char st Char

   means: stream is Char  
          user state type is st (not used)
          underlying monad: Char
          return type: not defined and ... tbd? or *is* defined by the types within 
            the body of the eol function?

  if I was to guess, the reason we can't do something like: 
    string "foo"
    - is because the compiler has no idea what our stream, state, underlying monad and
      return type is/will be. 
    - and the key is that wrapping the primitives up with GenParsers supplies all of that
      missing type information. 

*extremely well written* blog post about typeable: http://chrisdone.com/posts/data-typeable

http://chrisdone.com/posts/fast-haskell-c-parsing-xml
http://www.serpentine.com/criterion/

9/7/2017

*YouCanDoThis> :show modules
YouCanDoThis     ( C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv3.hs, interpreted )
*YouCanDoThis> x <- return 42
*YouCanDoThis> x
42
*YouCanDoThis> :browse System.IO
... 
*YouCanDoThis> :t openFile

<interactive>:1:1: error: Variable not in scope: openFile
*YouCanDoThis> :t System.IO.openFile
System.IO.openFile
  :: FilePath
     -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
<interactive>:17:54: error:
    Data constructor not in scope: ReadMode :: GHC.IO.IOMode.IOMode
*YouCanDoThis> x <- System.IO.openFile "..\\thingsToParse\\example.bond" System.IO.ReadMode
*YouCanDoThis> x
{handle: ..\thingsToParse\example.bond}
*YouCanDoThis> import System.IO
*YouCanDoThis System.IO> y <- openFile "..\\thingsToParse\\example.bond" ReadMode
*YouCanDoThis System.IO> y
{handle: ..\thingsToParse\example.bond}
------------

Briefly see if we can add forwarding items to the ParserCombinators docs. 
Then get back to learning about parsec generally. 

Ran into this trying to get 'stack haddock --open' to do anything: 
  (https://github.com/commercialhaskell/stack/issues/1396)

  c:\Users\brodyb\Documents\GitHub\parsec>stack init
  Looking for .cabal or package.yaml files to use to init the project.
  Using cabal packages:
  - parsec.cabal

  Selecting the best among 11 snapshots...

  Downloaded lts-9.3 build plan.
  Selected mirror https://s3.amazonaws.com/hackage.fpcomplete.com/
  Downloading timestamp
  Downloading snapshot
  Updating index
  Updated package list downloaded
  Populated index cache.
  * Partially matches lts-9.3
      HUnit version 1.5.0.0 found
          - parsec requires >=1.2 && <1.4

  Downloaded nightly-2017-09-07 build plan.
  Unable to parse cabal file: FromString "This package requires at least Cabal version 2.0" Nothing

I can't get anything to work with stack, stack init, stack haddock --open or anything with 
parsec. It's a confusing, demoralizing waste of time. Back to working with things that I can 
actually grapple :-)



8/31/2017

Am noticing that I can get complicated compile time errors that are really 
just due to inconsistent columns in do-blocks. 

fooOption3 :: GenParser Char st Char
fooOption3 = 
    do char 'a'
        char 'b' <|> return 'a'

Note the inconsistent column for 'do char' vs. 'char' on next block

This is made worse by Code's auto-indenting rules during copy/paste. You can
start with working code, paste it and it'll be broken by auto-indent. 

GenParser: http://hackage.haskell.org/package/parsec-3.1.11/docs/src/Text.Parsec.String.html#GenParser

how does do know we're working in the 
ParsecT monad?
How does one work with things like this
and any other value as a parameter?
myTest2 :: GenParser Char st Char -> Char
myTest2 c =
    do char 'a'
       char 'b' <|> return 'a' 

If you look at this doc: http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-ParserCombinators-Parsec-Prim.html#t:GenParser

I think the reason myTest2 fails to compile is because it's not a thing that 
parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a

can understand. Right? So parse requires a Parsec s () a, while we're defining another
thing entirely with myTest2

So who's complaining here? I'd have thought it was parse complaining about the 
signature of myTest2 not being a Parsec but apparently not?

Here's the error: 

Prelude> :l src\csv3.hs
[1 of 1] Compiling Main             ( src\csv3.hs, interpreted )

src\csv3.hs:37:8: error:
    * Couldn't match expected type `Char'
                  with actual type `Text.Parsec.Prim.ParsecT s0 u0 m0 Char'
    * In a stmt of a 'do' block: char 'a'
      In the expression:
        do { char 'a';
             char 'b' <|> return 'a' }
      In an equation for `myTest2':
          myTest2 c
            = do { char 'a';
                   char 'b' <|> return 'a' }
Failed, modules loaded: none.

So maybe the question is not how to make myTest2 take a parameter but 
rather make GenParser by parameters. Right now our GenParser is totally
static wrt parameters. What varies is the input from parser. 

8/30/2017

Ok, one thing that's confused me is that when I examine documentation on hackage
for the module at the top of the file I don't see functions I know I am using in
the source file. 

Example: 
  This is a module: Text.ParserCombinators.Parsec
  And this is the hackage doc: https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-ParserCombinators-Parsec.html

But on that page, there's no "string" functions
BUT, the modules listed at the top contain that function, (the third one belatedly)
So how would I have found out the third module had this function and gone there more directly?

Try :t in ghci?

*Main> :t string
string
  :: Text.Parsec.Prim.Stream s m Char =>
     String -> Text.Parsec.Prim.ParsecT s u m String

ha! :info!!!

*Main> :show imports
:module +*Main -- added automatically
*Main> :info string
string ::
  Text.Parsec.Prim.Stream s m Char =>
  String -> Text.Parsec.Prim.ParsecT s u m String
        -- Defined in `Text.Parsec.Char'

How to call eol?

*Main> :info parse
parse ::
  Text.Parsec.Prim.Stream s Data.Functor.Identity.Identity t =>
  Text.Parsec.Prim.Parsec s () a
  -> SourceName -> s -> Either ParseError a
        -- Defined in `Text.Parsec.Prim'
*Main> parse eol "" "\n"
Right "\n"

How to show functions loaded in function: (super cool)

Prelude> :l csv3.hs
[1 of 1] Compiling Main             ( csv3.hs, interpreted )
Ok, modules loaded: Main.
*Main> :browse
eol :: GenParser Char st [Char]
eol2 :: GenParser Char st [Char]

8/25/2017 

PR merged!!!

parse cells "(unknown)" "foo"
Working with csv1.hs in order to: 
1. understand more about Parsec
2. understand more about why the example does "cells" 
   rather than "many cell"
3. working with csv1.hs in ghci *incrementally* which 
   means working with tinier pieces of the code than 
   parseCSV

   ex. parse cells "(unknown)" "foo"
   need a helper for that... 

Success! Two helpers: 

p1 :: GenParser Char () [String] -> String -> Either ParseError [String]
p1 x input = parse x "(unknown)" input 

p2 :: GenParser Char () [[String]] -> String -> Either ParseError [[String]]
p2 x input = parse x "(unknown)" input 

example usage: 

*Csv1> p1 line "foo\n"
Right ["foo"]
*Csv1> p2 csvFile "foo\n"
Right [["foo"]]

Added this: 

csvFile' :: GenParser Char st [[String]]
csvFile' = 
    do 
        result <- many line2
        eof
        return result

line2 :: GenParser Char st [String]
line2 = 
    do 
        result <- many cellContent
        eol 
        return result

which was to answer my question of why you can't just do "many cellContent": 

*Csv1> p1 line2 "foo\n"
*** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.


8/24/2017

SENT A PR: for the broken parsec example: https://github.com/haskell/parsec/pull/76

stack new csv1 simple
stack setup --install-ghc

After I ran this it said this, which might be useful for not running this
slow command every time I want to ty some code: 

  GHC installed to C:\Users\brodyb\AppData\Local\Programs\stack\x86_64-windows\ghc-8.0.2\
  stack will use a sandboxed GHC it installed
  For more information on paths, see 'stack path' and 'stack exec env'
  To use this GHC and packages outside of a project, consider using:
  stack ghc, stack ghci, stack runghc, or stack exec

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:22:14: error:
      parse error on input `<-'
      Perhaps this statement should be within a 'do' block?

  Fix: put all lines in each do block that used <- on
    the exact same column

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:5:1: error:
      Failed to load interface for `Text.ParserCombinators.Parsec'
      Perhaps you meant
        Text.ParserCombinators.ReadPrec (from base-4.9.1.0)
        Text.ParserCombinators.ReadP (from base-4.9.1.0)
      Use -v to see a list of the files searched for.

  Fix: added parsec to csv.cabal 

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  mtl-2.2.1: configure
  mtl-2.2.1: build
  text-1.2.2.2: configure
  text-1.2.2.2: build
  mtl-2.2.1: copy/register
  text-1.2.2.2: copy/register
  parsec-3.1.11: configure
  parsec-3.1.11: build
  parsec-3.1.11: copy/register
  csv1-0.1.0.0: configure (exe)
  Configuring csv1-0.1.0.0...
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:33:16: error:
      * Expecting one more argument to `GenParser Char String'
        Expected a type, but `GenParser Char String' has kind `* -> *'
      * In the type signature:
          cellContent :: GenParser Char String
  Completed 4 action(s).

  Fix: 
    Changed this: cellContent :: GenParser Char String
    To      this: cellContent :: GenParser Char st String

Then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  csv1-0.1.0.0: configure (exe)
  Configuring csv1-0.1.0.0...
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )
  [2 of 2] Compiling Main             ( src\Main.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Main.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs:7:3: error:
      * Couldn't match type `Either Text.Parsec.Error.ParseError'
                      with `IO'
        Expected type: IO [[String]]
          Actual type: Either Text.Parsec.Error.ParseError [[String]]
      * In a stmt of a 'do' block: parseCSV "hi\n"
        In the expression:
          do { parseCSV "hi\n";
              putStrLn "hello world" }
        In an equation for `main':
            main
              = do { parseCSV "hi\n";
                    putStrLn "hello world" }

  Fix: added this to main: 

    case (parseCSV "hi\n") of 
      Left msg -> putStrLn msg
      Right output -> putStrLn output

  but even then: 

    C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs:9:30: error:
      * Couldn't match type `[String]' with `Char'
        Expected type: String
          Actual type: [[String]]
      * In the first argument of `putStrLn', namely `output'
        In the expression: putStrLn output
        In a case alternative: Right output -> putStrLn output

  Fix?
    The [[String]] problem is real of course
    For now I'm doing this: stack ghci src/csv1.hs

(stack.cabal builds everything in src/) add csv1.hs to that?
stack build that?
stack ghci that?


8/23/2017

What are the functions?
From which libraries are they from?
Read those docs
Play with them in the repl

type Parser a = ParsecT String Symbols (ReaderT Environment IO) a

Loaded Text.Parsec into ghci but the first example from 
here: https://hackage.haskell.org/package/parsec
gives: 

Prelude Text.Parsec> let parenSet = char '(' >> many parenSet >> char ')'

<interactive>:9:5:
    Non type-variable argument in the constraint: Stream s m Char
    (Use FlexibleContexts to permit this)
    When checking that `parenSet' has the inferred type
      parenSet :: forall s u (m :: * -> *).
                  Stream s m Char =>
                  ParsecT s u m Char

Found and commented on the bug for the above: https://github.com/haskell/parsec/issues/56

And the bug report has the fix: let parenSet = char '(' >> many parenSet >> char ')' :: Parsec String () Char
It'd be interesting when I have time to think about why that's the fix from a type perspective and the error message. 

8/19/2017

Made a failing syntax test for view_of in 438_
Switched to 438_t so I can: 
	- add parseSimple
	- see what the other tests do when they fail with a natural parse 

*Main> :load IO
[1 of 1] Compiling IO               ( IO.hs, interpreted )
Ok, modules loaded: IO.
*IO> :t parseSimple

ok: 

*IO> parseSimple "tests/schema/error/view_of_nothing.bond"
Bond {bondImports = [], bondNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], bondDeclarations = [Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "SomeStruct", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 0, fieldModifier = Optional, fieldType = BT_String, fieldName = "F1", fieldDefault = Nothing},Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]},Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "DubiousView", declParams = [], structBase = Nothing, structFields = []}]}

so, since this parses, THAT'S the bug, so we'll fix it to not parse...

I learned that if I 'stack ghci' it'll pull in Language.Bond.Parser which we can :browse
not sure how to get that type signature though for parseBond
point isn't to use parseSimple or even parseBondFile, point is to slim the call stack to the point 
where I can figure out the fix

parseSimple "tests/schema/error/view_of_nothing.bond"
parseBondFile [] "tests/schema/error/view_of_nothing.bond"
:t parseBond
parseBond
  :: Text.Parsec.Pos.SourceName
     -> String
     -> FilePath
     -> ImportResolver
     -> IO (Either Text.Parsec.Error.ParseError Bond)

-- 212
-- struct view parser
view :: Parser Declaration
view = do
    attr <- attributes
    name <- keyword "struct" *> identifier <?> "struct view definition"
    decl <- keyword "view_of" *> qualifiedName >>= findStruct
    fields <- braces $ semiOrCommaSepEnd1 identifier
    namespaces <- asks currentNamespaces
    Struct namespaces attr name (declParams decl) (structBase decl) (viewFields decl fields) <$ optional semi
  where
    viewFields Struct {..} fields = filter ((`elem` fields) . fieldName) structFields
    viewFields _           _      = error "view/viewFields: impossible happened."

-- 160
findStruct :: QualifiedName -> Parser Declaration
findStruct name = doFind <?> "qualified struct name"
  where
    doFind = do
        symb <- findSymbol name
        case symb of
            Struct {..} -> return symb
            _ -> fail $ "The " ++ showPretty symb ++ " is invalid in this context. Expected a struct."

Took these notes: 

-- struct view parser
view :: Parser Declaration
view = do
    attr <- attributes
    name <- keyword "struct" *> identifier <?> "struct view definition"
    -- this tells us what we're viewing
    decl <- keyword "view_of" *> qualifiedName >>= findStruct
    -- and this says what in what we're viewing we wish to view
    fields <- braces $ semiOrCommaSepEnd1 identifier
    -- so at this point we can ask: are (all? some?) fields in the viewed struct?
    namespaces <- asks currentNamespaces
    Struct namespaces attr name (declParams decl) (structBase decl) (viewFields decl fields) <$ optional semi
  where
    viewFields Struct {..} fields = filter ((`elem` fields) . fieldName) structFields
    viewFields _           _      = error "view/viewFields: impossible happened."


8/18/2017

trying to update my .ghci config and get it to load from %userprofile%
contents: :set prompt "\x03BB: "
Command to run ghci with test symbols: stack ghci --test --main-is gbc-tests
This might be even better: stack ghci tests\TestMain.hs
	- smaller build
	- good modules list
	- less in the prompt (why though?)

Parsing a file directly in ghci: 

stack ghci tests\TestMain.hs
parseFile [] "tests/schema/value_of.bond"

*Main IO System.IO System.Directory> parseFile [] "tests/schema/value_of.bond"
Bond {bondImports = [], bondNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], bondDeclarations = [Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "SomeStruct", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 0, fieldModifier = Optional, fieldType = BT_String, fieldName = "F1", fieldDefault = Nothing},Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]},Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "ValidView", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]}]}

added "parseSimple"
IO.parseSimple "tests/schema/value_of.bond"

NEXT: Syntax.hs has a "failBadSyntax" which we need to use 
to create a test for the struct that should fail value_of. Check that out! 