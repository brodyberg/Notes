8/24/2017

SENT A PR: for the broken parsec example: https://github.com/haskell/parsec/pull/76

stack new csv1 simple
stack setup --install-ghc

After I ran this it said this, which might be useful for not running this
slow command every time I want to ty some code: 

  GHC installed to C:\Users\brodyb\AppData\Local\Programs\stack\x86_64-windows\ghc-8.0.2\
  stack will use a sandboxed GHC it installed
  For more information on paths, see 'stack path' and 'stack exec env'
  To use this GHC and packages outside of a project, consider using:
  stack ghc, stack ghci, stack runghc, or stack exec

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:22:14: error:
      parse error on input `<-'
      Perhaps this statement should be within a 'do' block?

  Fix: put all lines in each do block that used <- on
    the exact same column

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:5:1: error:
      Failed to load interface for `Text.ParserCombinators.Parsec'
      Perhaps you meant
        Text.ParserCombinators.ReadPrec (from base-4.9.1.0)
        Text.ParserCombinators.ReadP (from base-4.9.1.0)
      Use -v to see a list of the files searched for.

  Fix: added parsec to csv.cabal 

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  mtl-2.2.1: configure
  mtl-2.2.1: build
  text-1.2.2.2: configure
  text-1.2.2.2: build
  mtl-2.2.1: copy/register
  text-1.2.2.2: copy/register
  parsec-3.1.11: configure
  parsec-3.1.11: build
  parsec-3.1.11: copy/register
  csv1-0.1.0.0: configure (exe)
  Configuring csv1-0.1.0.0...
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:33:16: error:
      * Expecting one more argument to `GenParser Char String'
        Expected a type, but `GenParser Char String' has kind `* -> *'
      * In the type signature:
          cellContent :: GenParser Char String
  Completed 4 action(s).

  Fix: 
    Changed this: cellContent :: GenParser Char String
    To      this: cellContent :: GenParser Char st String

Then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  csv1-0.1.0.0: configure (exe)
  Configuring csv1-0.1.0.0...
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )
  [2 of 2] Compiling Main             ( src\Main.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Main.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs:7:3: error:
      * Couldn't match type `Either Text.Parsec.Error.ParseError'
                      with `IO'
        Expected type: IO [[String]]
          Actual type: Either Text.Parsec.Error.ParseError [[String]]
      * In a stmt of a 'do' block: parseCSV "hi\n"
        In the expression:
          do { parseCSV "hi\n";
              putStrLn "hello world" }
        In an equation for `main':
            main
              = do { parseCSV "hi\n";
                    putStrLn "hello world" }

  Fix: added this to main: 

    case (parseCSV "hi\n") of 
      Left msg -> putStrLn msg
      Right output -> putStrLn output

  but even then: 

    C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs:9:30: error:
      * Couldn't match type `[String]' with `Char'
        Expected type: String
          Actual type: [[String]]
      * In the first argument of `putStrLn', namely `output'
        In the expression: putStrLn output
        In a case alternative: Right output -> putStrLn output

  Fix?
    The [[String]] problem is real of course
    For now I'm doing this: stack ghci src/csv1.hs

(stack.cabal builds everything in src/) add csv1.hs to that?
stack build that?
stack ghci that?


8/23/2017

What are the functions?
From which libraries are they from?
Read those docs
Play with them in the repl

type Parser a = ParsecT String Symbols (ReaderT Environment IO) a

Loaded Text.Parsec into ghci but the first example from 
here: https://hackage.haskell.org/package/parsec
gives: 

Prelude Text.Parsec> let parenSet = char '(' >> many parenSet >> char ')'

<interactive>:9:5:
    Non type-variable argument in the constraint: Stream s m Char
    (Use FlexibleContexts to permit this)
    When checking that `parenSet' has the inferred type
      parenSet :: forall s u (m :: * -> *).
                  Stream s m Char =>
                  ParsecT s u m Char

Found and commented on the bug for the above: https://github.com/haskell/parsec/issues/56

And the bug report has the fix: let parenSet = char '(' >> many parenSet >> char ')' :: Parsec String () Char
It'd be interesting when I have time to think about why that's the fix from a type perspective and the error message. 

8/19/2017

Made a failing syntax test for view_of in 438_
Switched to 438_t so I can: 
	- add parseSimple
	- see what the other tests do when they fail with a natural parse 

*Main> :load IO
[1 of 1] Compiling IO               ( IO.hs, interpreted )
Ok, modules loaded: IO.
*IO> :t parseSimple

ok: 

*IO> parseSimple "tests/schema/error/view_of_nothing.bond"
Bond {bondImports = [], bondNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], bondDeclarations = [Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "SomeStruct", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 0, fieldModifier = Optional, fieldType = BT_String, fieldName = "F1", fieldDefault = Nothing},Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]},Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "DubiousView", declParams = [], structBase = Nothing, structFields = []}]}

so, since this parses, THAT'S the bug, so we'll fix it to not parse...

I learned that if I 'stack ghci' it'll pull in Language.Bond.Parser which we can :browse
not sure how to get that type signature though for parseBond
point isn't to use parseSimple or even parseBondFile, point is to slim the call stack to the point 
where I can figure out the fix

parseSimple "tests/schema/error/view_of_nothing.bond"
parseBondFile [] "tests/schema/error/view_of_nothing.bond"
:t parseBond
parseBond
  :: Text.Parsec.Pos.SourceName
     -> String
     -> FilePath
     -> ImportResolver
     -> IO (Either Text.Parsec.Error.ParseError Bond)

-- 212
-- struct view parser
view :: Parser Declaration
view = do
    attr <- attributes
    name <- keyword "struct" *> identifier <?> "struct view definition"
    decl <- keyword "view_of" *> qualifiedName >>= findStruct
    fields <- braces $ semiOrCommaSepEnd1 identifier
    namespaces <- asks currentNamespaces
    Struct namespaces attr name (declParams decl) (structBase decl) (viewFields decl fields) <$ optional semi
  where
    viewFields Struct {..} fields = filter ((`elem` fields) . fieldName) structFields
    viewFields _           _      = error "view/viewFields: impossible happened."

-- 160
findStruct :: QualifiedName -> Parser Declaration
findStruct name = doFind <?> "qualified struct name"
  where
    doFind = do
        symb <- findSymbol name
        case symb of
            Struct {..} -> return symb
            _ -> fail $ "The " ++ showPretty symb ++ " is invalid in this context. Expected a struct."

Took these notes: 

-- struct view parser
view :: Parser Declaration
view = do
    attr <- attributes
    name <- keyword "struct" *> identifier <?> "struct view definition"
    -- this tells us what we're viewing
    decl <- keyword "view_of" *> qualifiedName >>= findStruct
    -- and this says what in what we're viewing we wish to view
    fields <- braces $ semiOrCommaSepEnd1 identifier
    -- so at this point we can ask: are (all? some?) fields in the viewed struct?
    namespaces <- asks currentNamespaces
    Struct namespaces attr name (declParams decl) (structBase decl) (viewFields decl fields) <$ optional semi
  where
    viewFields Struct {..} fields = filter ((`elem` fields) . fieldName) structFields
    viewFields _           _      = error "view/viewFields: impossible happened."


8/18/2017

trying to update my .ghci config and get it to load from %userprofile%
contents: :set prompt "\x03BB: "
Command to run ghci with test symbols: stack ghci --test --main-is gbc-tests
This might be even better: stack ghci tests\TestMain.hs
	- smaller build
	- good modules list
	- less in the prompt (why though?)

Parsing a file directly in ghci: 

stack ghci tests\TestMain.hs
parseFile [] "tests/schema/value_of.bond"

*Main IO System.IO System.Directory> parseFile [] "tests/schema/value_of.bond"
Bond {bondImports = [], bondNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], bondDeclarations = [Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "SomeStruct", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 0, fieldModifier = Optional, fieldType = BT_String, fieldName = "F1", fieldDefault = Nothing},Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]},Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "ValidView", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]}]}

added "parseSimple"
IO.parseSimple "tests/schema/value_of.bond"

NEXT: Syntax.hs has a "failBadSyntax" which we need to use 
to create a test for the struct that should fail value_of. Check that out! 