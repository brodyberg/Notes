1/5/2018

How does this make sense: 

*DogTypes> :t HuskyData
HuskyData :: HuskyType a
*DogTypes> :t HuskyData :: HuskyType String
HuskyData :: HuskyType String :: HuskyType String

Was expecting: 

*DogTypes> :t HuskyData :: HuskyType String
HuskyData :: HuskyType String

fails: 

*DogTypes> :t DogueDeBordeaux String :: DogueDeBordeaux String

<interactive>:1:17: error:
    Data constructor not in scope: String :: String

works: 

DogueDeBordeaux "foo" :: DogueDeBordeaux String
  :: DogueDeBordeaux String

data Doggies a = 
    Husky a 
  | Mastiff a 
  deriving (Eq, Show)

*DogTypes> :k Doggies
Doggies :: * -> *
*DogTypes> :k Doggies Int
Doggies Int :: *


12/15/2017

Observe: 

Prelude> c 3 $ c 4 $ c 5 $ c 6 7
3

The idea here is: 

3 + 4 + 5 + 6

as opposed to 

3 * 4 + 5 * 6 where the different operators (+) and (*) are competing for precedence. 

Furthermore, the idea is that, if we're in a foldr situation, and we evaluate from the 
left side because all the precedences are the same between all the functions since all 
the functions are const, then when we go to do this, the output is 1: 

xs = [1..5] ++ undefined
foldr const 0 xs

which *incorrectly* written out looks like: 

(const 1 (const 2 (const 3 (const 4 (const 5 (const ..? 0))))))

If you wrote it out this way, and I have many times, you'd assume the result would be: 

const ..? 0 which is exception

but if we instead look at it like 

const :: a -> b -> a
const x _ = x

and: 

const 1 _ 

Then the answer should be 1. 

12/14/2017

Prelude> let xs = [1..3] ++ undefined
Prelude> (const 1 (const 2 (const 3 (const undefined 0))))
1
Prelude> xs
[1,2,3*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err
  undefined, called at <interactive>:1:20 in interactive:Ghci1
Prelude> (const 1 (const 2 (const 3 0)))
1
Prelude> foldr const 0 xs
1
Prelude> (const 1 (const 2 (const 3 (const undefined 0))))
1
Prelude> (const 1 (const 2 (const 3 (const 5 0))))
1
Prelude> const 1 undefined
1
Prelude> const undefined 1
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err
  undefined, called at <interactive>:11:7 in interactive:Ghci8
Prelude> (const 1 (const undefined 3))
1
Prelude> (const 1 (const undefined undefined))
1
Prelude> 2^2^3
256
Prelude> 2^(2^3)
256
Prelude> (2^2)^3
64
Prelude> const 1 (const undefined undefined)
1
Prelude> :i const
const :: a -> b -> a    -- Defined in `GHC.Base'
Prelude> fc = flip const
Prelude> fc undefined 1
1
Prelude> (fc 1 (fc 2 (fc 3 4)))
4
Prelude> (fc 1 (fc 2 (fc 3 undefined)))
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
  error, called at libraries\base\GHC\Err.hs:79:14 in base:GHC.Err
  undefined, called at <interactive>:25:19 in interactive:Ghci17
Prelude> (fc undefined (fc 2 (fc 3 4)))
4
Prelude>


12/4/2017

http://www.stephendiehl.com/posts/haskell_2018.html
https://futtetennismo.me/posts/docker/2017-11-24-docker-haskell-executables.html

12/2/2017

Haskell PDBs: https://ghc.haskell.org/trac/ghc/ticket/12397

11/30/2017

Prelude> mySqr = [x^2 | x <- [1..10]]
Prelude> mySqr
[1,4,9,16,25,36,49,64,81,100]
Prelude> [x | x <- mySqr, rem x 2 == 0]
[4,16,36,64,100]
Prelude> [(x,y) | x <- mySqr, y <- mySqr, x < 50, y > 50]
[(1,64),(1,81),(1,100),(4,64),(4,81),(4,100),(9,64),(9,81),(9,100),(16,64),(16,81),(16,100),(25,64),(25,81),(25,100),(36,64),(36,81),(36,100),(49,64),(49,81),(49,100)]
Prelude> take 5 [(x,y) | x <- mySqr, y <- mySqr, x < 50, y > 50]
[(1,64),(1,81),(1,100),(4,64),(4,81)]
Prelude> :i elem
class Foldable (t :: * -> *) where
  ...
  elem :: Eq a => a -> t a -> Bool
  ...
        -- Defined in `Data.Foldable'
infix 4 `elem`
Prelude> elem 'a' "abracadabra"
True
Prelude> [x | x <- "Three Letter Acronym", elem x ['A'..'Z']]
"TLA"
Prelude> :l AcrosChapter9.hs
[1 of 1] Compiling Acros            ( AcrosChapter9.hs, interpreted )
Ok, modules loaded: Acros.
*Acros> acros "Three Letter Acronym"
"TLA"
*Acros> acros "National Aeronautics and Space Administration"
"NASA"

11/26/2017

How about a Haskell "get things done" library that is 
not physically monolithic but is of a uniform design?

The "where do i get started to do real work" library set?

11/20/2017

We could write, with Parsec a parser for .gitignore files
such that if you provided a file tree, and zero or more
.gitignore files we could provide you with a tree that 
represents all the items that are not ignored. 

The goal though would be to use that returned tree, in my 
case, for a buildtime validator. So maybe for that you 
could then call a function which yields all the files 
stored within the result tree.

comment: #
multi-line comment start/end: ###
wildcard: *
alternation: [] - we could generate the alternations
directory: /
glob: **
I think it's case-sensitive
rooting: starting with /
this is a folder: anything and /
  folder means: walk into tree
  file means:
barenames for file anywhere: msbuild.log

every rule is: 
  walk 
    zero 
    every
    specific 
    exact, fuzzy or alternating named directories into tree
  and delete
    exact, fuzzy or alternating name
  where name is file or directory

** not sure if .gitignore cares whether the thing is a 
  file or directory. 


So we get the given tree (how to users make this? and what is
it?) Then we get the [GitIgnore] and generate the list of 
items we'll slice out of our tree. We will then traverse the
tree, and each item in our list is an item to remove from the 
tree. And then the user needs to not only expect but be 
looking forward to using the return value. That could just
be a Rose Tree.

MVP: 
take path and one .gitignore with just names
generate tree
parse gitignore for the filenames
traverse the tree, removing each instance of name
return RoseTree representing pruned tree

11/19/2017

Essentially I'm saying: I'll use a parser I built to parse your XPath to build a parser for 
XML that will implement your XPath. Maybe I could even figure out how to eliminate the intermediate
step of parsing their XPath into an AST I then read in order to build a parser which implements
the semantics of their XPath. 

11/18/2017

I think there should be a way to use expertise built around XPath in Haskell. Right now
I can't find a way to use XPath but instead I see libraries built on their own combinators
etc. Theoretically what we could do is provide an api accepting strings in XPath format
which we then parse using Parsec but which themselves create Parsec parsers which 
implement the intention of the XPath. 

11/11/2017

:browse! will tell you where you might import something from

Super valuable: 

*Matching> :browse Data.Maybe
Data.Maybe.catMaybes :: [Maybe a] -> [a]
Data.Maybe.fromJust :: Maybe a -> a
Data.Maybe.fromMaybe :: a -> Maybe a -> a
Data.Maybe.isJust :: Maybe a -> Bool
Data.Maybe.isNothing :: Maybe a -> Bool
Data.Maybe.listToMaybe :: [a] -> Maybe a
Data.Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
maybe :: b -> (a -> b) -> Maybe a -> b
Data.Maybe.maybeToList :: Maybe a -> [a]
data Maybe a = Nothing | Just a
*Matching> :browse! Data.Maybe
-- not currently imported
Data.Maybe.catMaybes :: [Maybe a] -> [a]
Data.Maybe.fromJust :: Maybe a -> a
Data.Maybe.fromMaybe :: a -> Maybe a -> a
Data.Maybe.isJust :: Maybe a -> Bool
Data.Maybe.isNothing :: Maybe a -> Bool
Data.Maybe.listToMaybe :: [a] -> Maybe a
Data.Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
Data.Maybe.maybeToList :: Maybe a -> [a]
-- imported via Prelude
maybe :: b -> (a -> b) -> Maybe a -> b
Just :: a -> Maybe a
data Maybe a = Nothing | Just a
Nothing :: Maybe a

Also, here's the ghci command to show what we've defined at 
the console: 

*Matching> :show bindings
isItTwo :: Integer -> Bool = _
it :: Maybe Integer = Just 4

What's interesting there is it which I didn't even give a name to. 

11/10/2017 later...

Multi-line in ghci: 

Prelude> :{
Prelude| let trip :: Integer -> Integer
Prelude|     trip = \x -> x * 3
Prelude| :}
Prelude> :t trip
trip :: Integer -> Integer

bonkers! 

11/10/2017

Playing around with forM and mapM: 

<interactive>:1:1: error: Variable not in scope: forM
*Main> :m Control.Monad
Prelude Control.Monad> forM [1,2,3] (\n -> Some n)

<interactive>:3:21: error:
    Data constructor not in scope: Some :: Integer -> m b
Prelude Control.Monad> :t Maybe

<interactive>:1:1: error:
    * Data constructor not in scope: Maybe
    * Perhaps you meant variable `maybe' (imported from Prelude)
Prelude Control.Monad> :m +Data.Maybe
Prelude Control.Monad Data.Maybe> forM [1,2,3] (\n -> Some n)

<interactive>:6:21: error:
    Data constructor not in scope: Some :: Integer -> m b
Prelude Control.Monad Data.Maybe> :browse Data.Maybe
catMaybes :: [Maybe a] -> [a]
fromJust :: Maybe a -> a
fromMaybe :: a -> Maybe a -> a
isJust :: Maybe a -> Bool
isNothing :: Maybe a -> Bool
listToMaybe :: [a] -> Maybe a
mapMaybe :: (a -> Maybe b) -> [a] -> [b]
maybe :: b -> (a -> b) -> Maybe a -> b
maybeToList :: Maybe a -> [a]
data Maybe a = Nothing | Just a
Prelude Control.Monad Data.Maybe> forM [1,2,3] (\n -> Just n)
Just [1,2,3]
Prelude Control.Monad Data.Maybe> mapM (\n -> Just n) [1,2,3]
Just [1,2,3]

11/5/2017

Prelude> :show bindings
x :: Num t => t = _
y :: Num a => a = _
w :: Num a => a = _
z :: Num a => a -> a = _
f :: Fractional a => a = _
x' :: [Char] = _
y' :: [Char] = _
z' :: [Char] = _
f' :: [Char] = _
$trModule :: GHC.Types.Module = _
bigNum :: Num a => a = _

10/30/2017

Spent the week: thinking about the Either Monad as a model for operations 
that need to be sequenced but are in the context of failure. 

Spent the weekend: first heard and began reading about Indexed Monads
which appear to be Monad sequencing operations in the context of a
state-machine representing the states of some external system. 

10/23/2017

I'm also going through Haskell Programming from First Principles
so I've added learn.hs from Chapter 2. 


10/18/2017

Interesting - the Line constructor of Doc is used only
in prettify, not in PrettyJSON. PrettyJSON for renderJValue
really only consumes visible constructors, not things like
line, which makes me think that Tab is totally fine as an 
idea and will only be used inside of Prettify. 

Took my first really real stab at nest!
Realized so many things: 
- no need for Tab ctor since nest takes # of spaces
- need to figure out my recursive thing?
- need exhaustive pattern match
- use of replicate
- use of hcat
- is anyone using Prettify.concat?
- VS Code ghci command dies sometimes with lots of 
  ghc.exes listed in taskmanager

10/17/2017

Ok, so I think the key here is adding a new constructor for Doc, Tab. 

nest:: Int -> Doc -> Doc will transform a Doc into one that has Tabs

And, because we've added a constructor for Doc, we need to update all 
places that have Doc matches to ensure that they continue to be correct
and complete. 

My concern is how to add Tab within a "correct" context, ie. not in the
middle of a concat or union - but type safety should play a role here. 

Also, we should defer questions about adding a tab within a string for 
once this prototype is done. 

Also there's an opportunity here to do this with unit tests! 

http://documentup.com/feuerbach/tasty

do we need to import hunit? (yes: tasty-hunit)

After I added tasty to my cabal here's what stack ghci looked like: 

PS C:\Users\brodyb\Documents\GitHub\Notes> cd "c:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src"
PS C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src> stack ghci --ghci-options test.hs
clock-0.7.2: configure
stm-2.4.4.1: configure
clock-0.7.2: build
stm-2.4.4.1: build
regex-base-0.93.2: configure
regex-base-0.93.2: build
base-compat-0.9.3: configure
base-compat-0.9.3: build
stm-2.4.4.1: copy/register
regex-base-0.93.2: copy/register
async-2.1.1.1: configure
clock-0.7.2: copy/register
transformers-compat-0.5.1.4: download
async-2.1.1.1: build
regex-tdfa-1.2.2: configure
regex-tdfa-1.2.2: build
transformers-compat-0.5.1.4: configure
async-2.1.1.1: copy/register
transformers-compat-0.5.1.4: build
unbounded-delays-0.1.1.0: configure
transformers-compat-0.5.1.4: copy/register
unbounded-delays-0.1.1.0: build
tagged-0.8.5: download
tagged-0.8.5: configure
base-compat-0.9.3: copy/register
unbounded-delays-0.1.1.0: copy/register
tagged-0.8.5: build
ansi-terminal-0.6.3.1: configure
ansi-terminal-0.6.3.1: build
tagged-0.8.5: copy/register
ansi-terminal-0.6.3.1: copy/register
ansi-wl-pprint-0.6.7.3: configure
ansi-wl-pprint-0.6.7.3: build
ansi-wl-pprint-0.6.7.3: copy/register
optparse-applicative-0.13.2.0: download
optparse-applicative-0.13.2.0: configure
optparse-applicative-0.13.2.0: build
optparse-applicative-0.13.2.0: copy/register
regex-tdfa-1.2.2: copy/register
tasty-0.11.2.5: download
tasty-0.11.2.5: configure
tasty-0.11.2.5: build
tasty-0.11.2.5: copy/register
csv1-0.1.0.0: configure (exe)
Configuring csv1-0.1.0.0...
csv1-0.1.0.0: initial-build-steps (exe)
Completed 14 action(s).
Configuring GHCi with the following packages: csv1
Using main module: 1. Package `csv1' component exe:csv1 with main-is file: C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs
GHCi, version 8.0.2: http://www.haskell.org/ghc/  :? for help
[1 of 2] Compiling Csv1             ( C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Csv1.hs, interpreted )
[2 of 2] Compiling Main             ( C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs, interpreted )

C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs:8:26: error:
    * Couldn't match type `Text.Parsec.Error.ParseError' with `[Char]'
      Expected type: String
        Actual type: Text.Parsec.Error.ParseError
    * In the first argument of `putStrLn', namely `msg'
      In the expression: putStrLn msg
      In a case alternative: Left msg -> putStrLn msg

C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs:9:30: error:
    * Couldn't match type `[String]' with `Char'
      Expected type: String
        Actual type: [[String]]
    * In the first argument of `putStrLn', namely `output'
      In the expression: putStrLn output
      In a case alternative: Right output -> putStrLn output
Failed, modules loaded: Csv1.
Loaded GHCi configuration from C:\Users\brodyb\AppData\Local\Temp\ghci9724\ghci-script
[1 of 3] Compiling SimpleJSON       ( C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\SimpleJSON.hs, interpreted )
[2 of 3] Compiling Prettify         ( C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Prettify.hs, interpreted )

C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Prettify.hs:123:17: error:
    Not in scope: data constructor `Tab'

C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Prettify.hs:135:17: error:
    Not in scope: data constructor `Tab'
Failed, modules loaded: SimpleJSON.


10/16/2017

nest is: Int -> Doc -> Doc whereas 
pretty is Int -> Doc -> String so it's like pretty 
could call nest optionally and nest merely modifies
a doc, rather than creates a final representation 
of it (String)

So, if we read a Doc, how would we see a milemarker
from which to introduce a nesting. 

nest might feel a little like punctuate, 
is Doc -> [Doc] -> [Doc]
or group, or flatten

We need to be clear on how { is represented in a Doc. 
What is the difference, if any, between the left curly 
which opens an Object and one that is within a Doc

*TestingNest> renderJValue jvalue''
Concat (Concat (Char '{') (Concat (Concat (Concat (Concat (Concat (Char '"') (Concat (Char 'O') (Concat (Char 'a') (Concat (Char 't') (Concat (Char 'h') (Concat
(Char 'b') (Concat (Char 'r') (Concat (Char 'e') (Concat (Char 'a') (Concat (Char 'k') (Concat (Char 'e') (Char 'r')))))))))))) (Char '"')) (Text ": ")) (Concat
(Concat (Char '"') (Concat (Char 'S') (Concat (Char 'i') (Concat (Char 'n') (Concat (Char 'k') (Concat (Char ' ') (Concat (Char '{') (Concat (Char 'I') (Concat (
Char 'n') (Concat (Char 't') (Concat (Char 'o') (Concat (Char '}') (Concat (Char ' ') (Concat (Char 'S') (Concat (Char 'i') (Concat (Char 'n') (Concat (Char ' ')
 (Char 'I')))))))))))))))))) (Char '"'))) (Union (Char ' ') Line))) (Char '}')
*TestingNest> compact $ renderJValue jvalue''
"{\"Oathbreaker\": \"Sink {Into} Sin I\"\n}"
*TestingNest> putStrLn $ compact $ renderJValue jvalue''
{"Oathbreaker": "Sink {Into} Sin I"
}

I can't figure out how to key off of JValue because Doc isn't at that level. 
I can't figure out how to key off of Char because at the point when a pretty/compact 
or nest is working on a Char there's no context about whether it's in a value or 
the formatting to start an Object. 

*TestingNest> renderJValue jvalue2
Concat (Concat (Char '{') (Concat (Concat (Concat (Concat (Concat (Concat (Concat (Char '"') (Char 'k')) (Char '"')) (Text ": ")) (Concat (Concat (Char '"') (Con
cat (Char '{') (Concat (Char 'v') (Char '}')))) (Char '"'))) (Char ',')) (Union (Char ' ') Line)) (Concat (Concat (Concat (Concat (Concat (Char '"') (Concat (Cha
r 'k') (Char '2'))) (Char '"')) (Text ": ")) (Text "2.0")) (Union (Char ' ') Line)))) (Char '}')
*TestingNest> compact $ renderJValue jvalue2
"{\"k\": \"{v}\",\n\"k2\": 2.0\n}"
*TestingNest> putStrLn $ compact $ renderJValue jvalue2
{"k": "{v}",
"k2": 2.0
}

Wait, what about escaped double quotes?
or, maybe what I mean is: are we in a string? because if we're not and this Char is a '{' the thing after is indented. 

10/13/2017

Work up a sufficiently complicated example in ordre to motivate 'nest'

*TestingNest> putStrLn $ compact $ renderJValue jvalue
[{"Oathbreaker": "Sink Into Sin I",
"Fallujah": "Starlit Path",
"Agoraphobic Nosebleed": "Not a Daughter",
"Lut": "BoyToy"
},
[{"Mechanicum": ["Thanatar Siege Automaton",
"Mars Pattern Reaver Titan"
],
"Vlka Fenryka": ["Leman Russ",
true
]
}
]
]

*TestingNest> putStrLn $ pretty 80 $ renderJValue jvalue
[{"Oathbreaker": "Sink Into Sin I", "Fallujah": "Starlit Path",
"Agoraphobic Nosebleed": "Not a Daughter", "Lut": "BoyToy" },
[{"Mechanicum": ["Thanatar Siege Automaton", "Mars Pattern Reaver Titan" ],
"Vlka Fenryka": ["Leman Russ", true ] } ] ]

For nest, we have a choice, which level would we like to work?
  - Char?
  - Doc?
  - JValue?

Does the suggestion from the author to call it nest and use the parameters
Int -> Doc -> Doc imply placing the function in prettify.hs and then having
it be one step lower in abstraction than renderJValue :: JValue -> Doc?

10/6/2017

Wow, today I forgot my PC at work so I rolled forward by converting the PrettyJSON
project to Haskell for Mac and it just worked. I was able to calmly and confidently
work through each error I faced in turn and solve all of them directly and with 
puzzling focused specifically on a set of likely solutions as opposed to getting 
huge bewildering errors whose solution could be anything. 

It was a very, very cool feeling to know how much I'd learned and how I could 
handle the situations presented to me by Haskell. The issues I faced were all 
exposing certain symbols through module imports and I was totally able to 
figure that out. 

10/5/2017

Considering Chapter 5 of Real World Haskell. There are things I still don't 
quite get. 
  * Wasn't super sure about this | syntax: 
          nicest col a b | (width - least) `fits` a = a
                         | otherwise                = b
                         where least = min width col
    But that's pretty clear to be simple case syntax and each
    clause in a | is simply looking for True in order to 
    return the RHS
  * Not super 100% sure about the unicode stuff
  * The author really likes infix for stuff like this: 
      fits :: Int -> String -> Bool
      w `fits` _ | w < 0 = False
      w `fits` ""        = True
      w `fits` ('\n':_)  = True
      w `fits` (c:cs)    = (w - 1) `fits` cs
    I think it feels awkward
  * The author made interesting choices as far as which little 
    functions to make and how to combine them. It's strange though
    because now that I read through the whole file for chapter 5 
    aka Prettify it feels so clear and straightforward... 
  
I think I *do* like infix syntax for some operators: 
   foo <> bar
   bar </> baz
but less for things like 
   x `Concat` y
maybe because of the backticks

Questions: 
  * Can we answer the practice questions?
    * fill :: Int -> Doc -> Doc 
      adds spaces to a doc until it is the given number of columns wide
    * nest :: Int -> Doc -> Doc
      When we open a parentheses the following lines should be indented by Int  
      so they are aligned with the opening character until a matching closing
      parentheses is found. 
    * Can we read this, as the author recommends? http://belle.sourceforge.net/doc/hughes95design.pdf

10/3/2017

We're ready to check this out: https://mail.haskell.org/pipermail/beginners/2017-October/017832.html
with response here: https://mail.haskell.org/pipermail/beginners/2017-October/017833.html
 
10/2/2017

We are on this level

compact $ renderJValue (JObject [("name",JString "value")])
"{\"name\": \"value\"\n}"
*PrettyJSON Prelude> compact $ renderJValue (JBool True)
"true"
*PrettyJSON Prelude> compact $ renderJValue (JArray [(JBool True)])
"[true\n]"
*PrettyJSON Prelude> compact $ renderJValue (JArray [(JBool True), (JBool False)])
"[true,\nfalse\n]"
*PrettyJSON Prelude> compact $ renderJValue (JObject [("name",JArray [(JBool True), (JString "foo")])])
"{\"name\": [true,\n\"foo\"\n]\n}"

*PrettyJSON Prelude> thing = compact $ renderJValue (JObject [("name",JArray [(JBool True), (JString "foo")])])
*PrettyJSON Prelude> :t thing
thing :: String
*PrettyJSON Prelude> thing2 = renderJValue (JObject [("name",JArray [(JBool True), (JString "foo")])])
*PrettyJSON Prelude> :t thing2
thing2 :: Doc

*PrettyJSON> char 'f' <> string "oo"
Concat (Char 'f') (Concat (Concat (Char '"') (Concat (Char 'o') (Char 'o'))) (Char '"'))
*PrettyJSON> char 'f' <> text "oo"
Concat (Char 'f') (Text "oo")
*PrettyJSON> :t text
text :: String -> Doc
*PrettyJSON> :t string
string :: String -> Doc

9/22/2017

Keep on Brody. You are getting this. It's work and it's tiring, but you are totally doing it 
and will get to your goal with this work of every day chipping away. 

Question: how do I read this type signature into understanding there are two required parameters?

  Prelude> :m Numeric
  Prelude Numeric> :info showHex
  showHex :: (Integral a, Show a) => a -> ShowS
          -- Defined in `Numeric'
  Prelude Numeric> showHex 4

  <interactive>:9:1: error:
      * No instance for (Show ShowS) arising from a use of `print'
          (maybe you haven't applied a function to enough arguments?)
      * In a stmt of an interactive GHCi command: print it
  Prelude Numeric> showHex 4 ""
  "4"

So you have to pass "" along with 4 to get showHex to work. But the type of showHex 
appears to only require one parameter: a which has two typeclass constraints. 

here's the answer: ShowS is a thing. If we look at the source for showHex we see 
https://hackage.haskell.org/package/base-4.10.0.0/docs/src/Numeric.html#showHex
https://hackage.haskell.org/package/base-4.10.0.0/docs/Text-Show.html#t:ShowS

  Prelude Numeric> showHex 4 ""
  "4"
  Prelude Numeric> :t showHex
  showHex :: (Show a, Integral a) => a -> ShowS
  Prelude Numeric> x = showHex 4
  Prelude Numeric> :t x
  x :: ShowS
  Prelude Numeric> :info ShowS
  type ShowS = String -> String   -- Defined in `GHC.Show'
  Prelude Numeric> x ""
  "4"
  Prelude Numeric> x "a"
  "4a"

9/20/2017

Having a tough time reading this: 

  p_series :: Char -> CharParser () a -> Char -> CharParser () [a]
  p_series left parser right = 
      between (char left <* spaces) (char right) $
              (parser <* spaces) `sepBy` (char ',' <* spaces)

Problem is: 
  between is just a function: 
    *YouCanDoThis> :info between
    between ::
      Text.Parsec.Prim.Stream s m t =>
      Text.Parsec.Prim.ParsecT s u m open
      -> Text.Parsec.Prim.ParsecT s u m close
      -> Text.Parsec.Prim.ParsecT s u m a
      -> Text.Parsec.Prim.ParsecT s u m a
            -- Defined in `Text.Parsec.Combinator'
  but i can't curry it: 

*YouCanDoThis> k = between (char '[')

  <interactive>:68:1: error:
      * Non type-variable argument
          in the constraint: Text.Parsec.Prim.Stream s m Char
        (Use FlexibleContexts to permit this)
      * When checking the inferred type
          k :: forall a close (m :: * -> *) u s.
              Text.Parsec.Prim.Stream s m Char =>
              Text.Parsec.Prim.ParsecT s u m close
              -> Text.Parsec.Prim.ParsecT s u m a
              -> Text.Parsec.Prim.ParsecT s u m a

  But I got it to work!!!!
  I had to do this in ghci: 
  *YouCanDoThis> :set -XFlexibleContexts
  *YouCanDoThis> k = between (char '[')
  *YouCanDoThis>

  *YouCanDoThis> k = between (char '[')
  *YouCanDoThis> :t k
  k :: Text.Parsec.Prim.Stream s m Char =>
      Text.Parsec.Prim.ParsecT s u m close
      -> Text.Parsec.Prim.ParsecT s u m a
      -> Text.Parsec.Prim.ParsecT s u m a
  *YouCanDoThis> l = between (char '[') (char ']')
  *YouCanDoThis> :t l
  l :: Text.Parsec.Prim.Stream s m Char =>
      Text.Parsec.Prim.ParsecT s u m a
      -> Text.Parsec.Prim.ParsecT s u m a
  *YouCanDoThis> :browse
  p_query :: CharParser () [(String, Maybe String)]
  p_pair :: CharParser () (String, Maybe String)
  p_pair_app1 :: CharParser () (String, Maybe String)
  urlBaseChars :: [Char]
  p_char :: CharParser () Char
  a_char :: CharParser () Char
  a_pair :: CharParser () (String, Maybe String)
  p_ha :: CharParser () Char
  p_hab :: CharParser () (Char, Char)
  p_hex :: CharParser () Char
  hexify :: Char -> Char -> Char
  mine :: Char -> Char -> String
  a_hex :: CharParser () Char
  *YouCanDoThis> :t l a_pair
  l a_pair
    :: Text.Parsec.Prim.ParsecT
        [Char] () Data.Functor.Identity.Identity (String, Maybe String)
  *YouCanDoThis> m = l a_pair
  *YouCanDoThis> parse m "" "[f]"
  Right ("f",Nothing)
  *YouCanDoThis> parse m "" "[f=%21]"
  Right ("f",Just "!")

Explanation of FlexibleContexts: 
  https://stackoverflow.com/questions/31251163/what-is-the-flexiblecontexts-extension-is-good-for-could-you-please-explain-it

Ok, so huge: we got currying to work for parsers, which will allow us to 
build them up incrementally which we couldn't before which made them seem 
more mysterious than they needed to be. 

Now: how and why are these different: 

  m :: Text.Parsec.Prim.ParsecT
          [Char] () Data.Functor.Identity.Identity (String, Maybe String)

  p_series :: Char -> CharParser () a -> Char -> CharParser () [a]
  p_series left parser right = 
      between (char left <* spaces) (char right) $
              (parser <* spaces) `sepBy` (char ',' <* spaces)

m is curried between. 
p_series is 
  a function on three arguments, left and right are chars, parser is a parser
  which then *calls* between, 
    wrapping left and right in parsers and a space-eater
    and then applying sepBy to the argument passed to the function this whole shebang creates
      and then passes the result of *that* as the third argument to between. 
  So the reason i was confused about $:
    I was forgetting we're creating a function to be returned
    we need to feed that function
    when we're done feeding that function, we'll need $ in order to run it and feed the 
      result value as parameter three of between. 
 

9/19/2017

  *YouCanDoThis> parse (char '%' *> hexDigit) "" "%f"
  Right 'f'
  *YouCanDoThis> :info (*>)
  class Functor f => Applicative (f :: * -> *) where
    ...
    (*>) :: f a -> f b -> f b
    ...
          -- Defined in `GHC.Base'
  infixl 4 *>

With our version of Haskell do we need to do the Applicative
thing that Real World Haskell does? Doesn't the version we 
use set all that up? How would we prove this?

  *YouCanDoThis> :t readHex $ []
  readHex $ [] :: (Num a, Eq a) => [(a, String)]
  *YouCanDoThis> :t ($)
  ($) :: (a -> b) -> a -> b
  *YouCanDoThis> -- $ fmap readHex across our list
  *YouCanDoThis> :t fmap
  fmap :: Functor f => (a -> b) -> f a -> f b
  *YouCanDoThis> -- *map* readHex across our list
  *YouCanDoThis> :t readHex $ ['9','a']
  readHex $ ['9','a'] :: (Num a, Eq a) => [(a, String)]
  *YouCanDoThis> readHex $ ['9','a']
  [(154,"")]
  *YouCanDoThis> readHex $ ['9','a','c']
  [(2476,"")]
  *YouCanDoThis> x b = b * 2
  *YouCanDoThis> x $ [1,2]

  <interactive>:64:1: error:
      * Non type-variable argument in the constraint: Num [t]
        (Use FlexibleContexts to permit this)
      * When checking the inferred type
          it :: forall t. (Num [t], Num t) => [t]
  *YouCanDoThis> :t x
  x :: Num a => a -> a
  *YouCanDoThis> x $ [1,2] :: Int

  <interactive>:66:1: error:
      * Couldn't match expected type `Int' with actual type `[t0]'
      * In the expression: x $ [1, 2] :: Int
        In an equation for `it': it = x $ [1, 2] :: Int
  *YouCanDoThis> x $ [1,2] :: Num

  <interactive>:67:14: error:
      * Expecting one more argument to `Num'
        Expected a type, but `Num' has kind `* -> Constraint'
      * In an expression type signature: Num
        In the expression: x $ [1, 2] :: Num
        In an equation for `it': it = x $ [1, 2] :: Num
  *YouCanDoThis> :t [1,2]
  [1,2] :: Num t => [t]
  *YouCanDoThis> x $ [1,2]

  <interactive>:69:1: error:
      * Non type-variable argument in the constraint: Num [t]
        (Use FlexibleContexts to permit this)
      * When checking the inferred type
          it :: forall t. (Num [t], Num t) => [t]
  *YouCanDoThis> x 4
  8
  *YouCanDoThis> fmap x [1,2]
  [2,4]
  *YouCanDoThis> :t readHex $ ['9','a']
  readHex $ ['9','a'] :: (Num a, Eq a) => [(a, String)]
  *YouCanDoThis>

What I'm trying to do is understand the use of $ with readHex. I thought 
it was fmap but really it's just map. But I still don't completely get it. 

readHex $ [a,b] is just saying "readhex is a function (a->b) that we're going
to apply to a value. How do we read readHex as a value?
  *YouCanDoThis> :info readHex
  readHex :: (Eq a, Num a) => ReadS a     -- Defined in `Numeric'
  *YouCanDoThis> :info ReadS a

  <interactive>:1:1: error: Not in scope: `a'
  *YouCanDoThis> :info ReadS
  type ReadS a = String -> [(a, String)]
          -- Defined in `Text.ParserCombinators.ReadP'

this shows that readHex is a ReadS a which is String -> [(a, String)]
so readHex $ [a,b] is 
   (String -> [(a, String)]) $ [Char,Char] which is the same as: 
   (String -> [(a, String)]) $ String -- specifically, a two Char string

well jesus, hex is two digits so we go to all this effort [a,b] to 
construct a two-digit string and then process it into hex. Woo. 

--- 

considering: 

  a_hex :: CharParser () Char
  a_hex = hexify <$> (char '%' *> hexDigit) <*> hexDigit

what's the order of evaluation? 
  1. pass by a '%'
  2. parse and keep a hexDigit
  3. parse and keep a hexDigit
  4. apply hexify to (which?) applicative functor? list?

Making rando parsers using combinators: 

  *YouCanDoThis> parse (char 'a' *> char 'b') "" "a"
  Left (line 1, column 2):
  unexpected end of input
  expecting "b"
  *YouCanDoThis> parse (char 'a' *> char 'b') "" "ab"
  Right 'b'
  *YouCanDoThis> parse (char 'a' <*> char 'b') "" "ab"

  <interactive>:31:8: error:
      * Couldn't match type `Char' with `Char -> a'
        Expected type: Text.Parsec.Prim.ParsecT
                        [Char] () Data.Functor.Identity.Identity (Char -> a)
          Actual type: Text.Parsec.Prim.ParsecT
                        [Char] () Data.Functor.Identity.Identity Char
      * In the first argument of `(<*>)', namely char 'a'
        In the first argument of `parse', namely `(char 'a' <*> char 'b')'
        In the expression: parse (char 'a' <*> char 'b') "" "ab"
      * Relevant bindings include
          it :: Either ParseError a (bound at <interactive>:31:1)
  *YouCanDoThis> parse (char 'a' <* char 'b') "" "ab"
  Right 'a'
  *YouCanDoThis> parse (char 'a' <* char 'b') "" "ac"
  Left (line 1, column 2):
  unexpected "c"
  expecting "b"

seems harder to use <*> than <* or *> why is that? why does the <*> version 
produce a function while the <* *> appear to not?

  *YouCanDoThis> :info (*>)
  class Functor f => Applicative (f :: * -> *) where
    ...
    (*>) :: f a -> f b -> f b
    ...
          -- Defined in `GHC.Base'
  infixl 4 *>
  *YouCanDoThis> :info (<*)
  class Functor f => Applicative (f :: * -> *) where
    ...
    (<*) :: f a -> f b -> f a
          -- Defined in `GHC.Base'
  infixl 4 <*
  *YouCanDoThis> :info (<*>)
  class Functor f => Applicative (f :: * -> *) where
    ...
    (<*>) :: f (a -> b) -> f a -> f b
    ...
          -- Defined in `GHC.Base'
  infixl 4 <*>

You can see that <*> requires a functor containing a function, 
not just a functor. so we have to do this: 

  *YouCanDoThis> parse ((,) <$> (char 'a') <*> char 'b') "" "ab"
  Right ('a','b')

What that does is say: I have a tuple constructor, which takes two things and
I want to apply that constructor as a function to the following two functors. 

Intuition was just that I need a functor to gather all the results of <*> up. 
And the one functor I know of that takes two things is (,) so I tried to use
it with <$> and it worked. 

  *YouCanDoThis> parse ((,) <$> (char 'a' <* char '%') <*> char 'b') "" "ab"
  Left (line 1, column 2):
  unexpected "b"
  expecting "%"
  *YouCanDoThis> parse ((,) <$> (char 'a' <* char '%') <*> char 'b') "" "a%b"
  Right ('a','b')

And this shows that we can further bracket parsers to require and then ignore
things and still get the <$> to apply (,) for our <*> result. 

oh, I think the reason we match the text with % first is because <*> applies
LEFT to RIGHT. 

Now just typing in a_pair and watching it work: 

  *YouCanDoThis> parse a_pair "" "foo"
  Right ("foo",Nothing)
  *YouCanDoThis> parse a_pair "" "f+o"
  Right ("f o",Nothing)
  *YouCanDoThis> parse a_pair "" "f+o=%21"
  Right ("f o",Just "!")
  *YouCanDoThis>

9/18/2017

What are our types here: 

p_pair_app1 :: CharParser () (String, Maybe String)
p_pair_app1 = 
    liftM2 (,) (many1 p_char) (optionMaybe (char '=' >> many p_char))

:t many1
many1
  :: Text.Parsec.Prim.Stream s m t =>
     Text.Parsec.Prim.ParsecT s u m a
     -> Text.Parsec.Prim.ParsecT s u m [a]

So the return value of many1 is a Text.Parsec.Prim.ParsecT s u m [a] 
how the F do we extract [a] out of that for our LiftM2 (,) operation?

:t p_char 
p_char :: CharParser () Char

ok, so the return value of p_char falls into the types for ParsecT. 

I wonder if there's a thing with Monad Transformers where when we run
them under Monad operations we "just" get a "certain" monad within the 
stack of monads in the transformer. 

*YouCanDoThis> :t optionMaybe
optionMaybe
  :: Text.Parsec.Prim.Stream s m t =>
     Text.Parsec.Prim.ParsecT s u m a
     -> Text.Parsec.Prim.ParsecT s u m (Maybe a)

So optionMaybe is just a function which accepts a parser and possibly 
returns the Nothing rather than failure. 

Back to liftM2, so it's lifting *by* an operation. An operation is a thing
like (+) or in our case (,). So depending on the incoming monad (list, Maybe
or whatever) we apply our arguments *left to right* to (,)

9/15/2017

Reading this: https://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html
I ran into 'go' which led me to this: 
https://stackoverflow.com/questions/5844653/haskell-why-the-convention-to-name-a-helper-function-go
who pointed me to this: 
http://book.realworldhaskell.org/read/profiling-and-optimization.html#id678845

moral of the story: keep reading rwh and profile profile profile! 

Using the applicative p_pair: 

  [1 of 1] Compiling YouCanDoThis     ( C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\queryString.hs, interpreted )
  Ok, modules loaded: YouCanDoThis.
  Loaded GHCi configuration from C:\Users\brodyb\AppData\Local\Temp\ghci8648\ghci-script
  *YouCanDoThis> :l queryString.hs
  [1 of 1] Compiling YouCanDoThis     ( queryString.hs, interpreted )
  Ok, modules loaded: YouCanDoThis.
  *YouCanDoThis> :browse
  p_query :: CharParser () [(String, Maybe String)]
  p_pair :: CharParser () (String, Maybe String)
  p_pair_app1 :: CharParser () (String, Maybe String)
  urlBaseChars :: [Char]
  p_char :: CharParser () Char
  p_ha :: CharParser () Char
  p_hab :: CharParser () (Char, Char)
  p_hex :: CharParser () Char
  *YouCanDoThis> :info p_pair_app1
  p_pair_app1 :: CharParser () (String, Maybe String)
          -- Defined at queryString.hs:19:1
  *YouCanDoThis> parseTest p_pair_app1 "a=b"
  ("a",Just "b")
  *YouCanDoThis> parseTest p_pair_app1 "a%21=b+c"
  ("a!",Just "b c")
  *YouCanDoThis> :info ap

  <interactive>:1:1: error: Not in scope: `ap'
  *YouCanDoThis> :import Control.Applicative
  unknown command ':import'
  use :? for help.
  *YouCanDoThis> :module Control.Applicative
  Prelude Control.Applicative> :info ap

  <interactive>:1:1: error: Not in scope: `ap'
  Prelude Control.Applicative> :module Control.Monad
  Prelude Control.Monad> :info ap
  ap :: Monad m => m (a -> b) -> m a -> m b       -- Defined in `GHC.Base'
  Prelude Control.Monad> :info mplus
  class (GHC.Base.Alternative m, Monad m) =>
        MonadPlus (m :: * -> *) where
    ...
    mplus :: m a -> m a -> m a
          -- Defined in `GHC.Base'
  Prelude Control.Monad> :info mplus
  class (GHC.Base.Alternative m, Monad m) =>
        MonadPlus (m :: * -> *) where
    ...
    mplus :: m a -> m a -> m a
          -- Defined in `GHC.Base'

9/12/2017

Ok, so what *is* a bond file?
a namespace
followed by (zero?) or more
  - struct
  - using
  - enum
  - service

struct:
  - struct
  - space
  - Identifier
  - Zero or more of: 
    - Angle Brackets
    - capture Identifier
  - If this struct is generic
    - space
    - colon
    - Identifier
  - OR
  - Zero or one of:  
    - space
    - colon
    - Identifier
    - Zero or one of:
      - Angle Brackets
  - ; 
  - OR
  - left curly brace
  - zero or more of
    - int (strictly increasing?)
    - colon
    - space
    - TypeThingy
    - Identifier (of existing)
      - Zero or more of
        - Angle Brackets  
      - space
      - Name
      - Zero or more of
        - space
        - equal
        - Identifier
      - semi-colon
  - right curly brace

TypeThingy: 
  - refer to existing type
  - keyword: ex. nullable

using: 
  - using
  - space
  - Identifier
  - Angle Brackets
  - space
  - equal
  - Identifier that was in the Angle Brackets
  - semi-colon

- Should Identifier include the
  notion of possibly having angle brackets?
- So Identifier would return the name
  and an Option for generic?

Angle Brackets: 
  - Left
  - Identifier (of existing thing?!)
  - Right

Identifier:
  - Capital letters
  - zero or more letters
  - ends with non-letter
  * the letters must refer to create something real
    * primitives: ex. string
    * T creating something real in struct Node<T>
    * 0: nullable<Node<T> referring to something real in 

Name: 
  - any letter 
  - any alpha-numeric
  - ends with non-alphanumeric

What we should do: 
- finish reading about parsing with Applicative Functors
- get comfortable with the Applicative style
- continue parsing real examples from bond files
- build a parser that can parse the things
- but how do we traverse what we parsed?

Getting toEnum to work: 

  *YouCanDoThis> :t toEnum
  toEnum :: Enum a => Int -> a
  *YouCanDoThis> toEnum 5
  *** Exception: Prelude.Enum.().toEnum: bad argument
  *YouCanDoThis> :info toEnum
  class Enum a where
    ...
    toEnum :: Int -> a
    ...
          -- Defined in `GHC.Enum'
  *YouCanDoThis> :t 5
  5 :: Num t => t
  *YouCanDoThis> toEnum (5::Int)
  *** Exception: Prelude.Enum.().toEnum: bad argument
  *YouCanDoThis> :t (5::Int)
  (5::Int) :: Int
  *YouCanDoThis> toEnum True

  <interactive>:10:8: error:
      * Couldn't match expected type `Int' with actual type `Bool'
      * In the first argument of `toEnum', namely `True'
        In the expression: toEnum True
        In an equation for `it': it = toEnum True
  *YouCanDoThis> toEnum 1
  *** Exception: Prelude.Enum.().toEnum: bad argument
  *YouCanDoThis> (toEnum 1)::String

  <interactive>:12:2: error:
      * No instance for (Enum String) arising from a use of `toEnum'
      * In the expression: (toEnum 1) :: String
        In an equation for `it': it = (toEnum 1) :: String
  *YouCanDoThis> (toEnum 1)::Bool
  True
  *YouCanDoThis> (toEnum 1)::Int
  1
  *YouCanDoThis> (toEnum 5)::Int
  5

9/9/2017

Wrote my first pair of combinators that do a thing! 

Since the first line of a bond file is a namespace declaration 
I wrote a thing that concieves of a namespace as blocks of 
letters separated by dots. It works! Example: 

Prelude> :l parseBond.hs
[1 of 1] Compiling YouCanDoThis     ( parseBond.hs, interpreted )
Ok, modules loaded: YouCanDoThis.
*YouCanDoThis> parse namespace "(unknown)" "foo.bar"
Right ["foo","bar"]

This is a huge moment because it's a couple of combinators
rather than a monolithic thing in a monad, and it's my thing
rather than from the book AND it has bugs :-) the bugs are that
if you pass it non-letters the parser will return empty strings
which is confusing to me at this point. But hells yes! 

9/8/2017

I read a whole file!

https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Char.html

We need to somehow figure out that using all these primitive 
combinators is using an entire parser as a whole

I say that because I can't get simple stuff to work: 

Prelude>import Text.ParserCombinators.Parsec
Prelude Text.ParserCombinators.Parsec> char ';'

<interactive>:16:1: error:
    * Non type-variable argument
        in the constraint: Text.Parsec.Prim.Stream s m Char
      (Use FlexibleContexts to permit this)
    * When checking the inferred type
        it :: forall (m :: * -> *) u s.
              Text.Parsec.Prim.Stream s m Char =>
              Text.Parsec.Prim.ParsecT s u m Char
Prelude Text.ParserCombinators.Parsec> semicolon = char ';'

also fails: 

Prelude Text.ParserCombinators.Parsec> let semicolon = char ';'

<interactive>:18:5: error:
    * Non type-variable argument
        in the constraint: Text.Parsec.Prim.Stream s m Char
      (Use FlexibleContexts to permit this)
    * When checking the inferred type
        semicolon :: forall (m :: * -> *) u s.
                     Text.Parsec.Prim.Stream s m Char =>
                     Text.Parsec.Prim.ParsecT s u m Char

do our (really real-world haskell's) eol and Text.Parsec.Char string have the 
same signature? If they do, then we should be able to run them through 'parse'
if not.. then think of what next. How would we characterize (pun) the difference?

Totally different, eol is a parser, string is a ...

Prelude Text.ParserCombinators.Parsec> :l parseBond.hs
[1 of 1] Compiling YouCanDoThis     ( parseBond.hs, interpreted )
Ok, modules loaded: YouCanDoThis.
*YouCanDoThis Text.ParserCombinators.Parsec> :browse YouCanDoThis
eol :: GenParser Char st Char
*YouCanDoThis Text.ParserCombinators.Parsec> :t eol
eol :: GenParser Char st Char
*YouCanDoThis Text.ParserCombinators.Parsec> parse eol "(unknown)" "\n"
Right '\n'

*YouCanDoThis Text.ParserCombinators.Parsec> :t string
string
  :: Text.Parsec.Prim.Stream s m Char =>
     String -> Text.Parsec.Prim.ParsecT s u m String
*YouCanDoThis Text.ParserCombinators.Parsec> :t endBy
endBy
  :: Text.Parsec.Prim.Stream s m t =>
     Text.Parsec.Prim.ParsecT s u m a
     -> Text.Parsec.Prim.ParsecT s u m sep
     -> Text.Parsec.Prim.ParsecT s u m [a]

So look: eol and what RWH has us writing feels "one level higher" than the things
in Parsec. eol etc are GenParsers while string etc are functions on ParsecT. 

string signature looks like: ParsecT -> ParsecT -> ParsecT but the items within the ParsecT
are different: s u m a -> s u m sep -> s u m [a]

so INSIDE of a GenParser we can use the primitives. so what makes a GenParser? 
something about using a primitive?

*YouCanDoThis Text.ParserCombinators.Parsec> :info GenParser
type GenParser tok st = Text.Parsec.Prim.Parsec [tok] st :: * -> *
        -- Defined in `Text.Parsec.String'

  I read this as: there's a type called GenParser constructed with a list of tokens (anything)
  and an st, whatever that is and is then realized as a one argument to one argument function. 

  so if you :t a thing we've GenParser you'd ... see * -> * somehow?
  also: how is it that my reading of GenParser says the ctor takes two values when
  the code from RWH clearly passes in three things?

https://hackage.haskell.org/package/parsec-3.1.11/docs/src/Text.Parsec.String.html#Parser

that shows that Text.Parsec.String gives us

   type Parser = Parsec String ()

   which I describe as "A Parsec whose Stream argument is a String, and whose 
   user state type is nothing." BUT THIS IS SOMEHOW CURRIED AT THE TYPE LEVEL and 
   so Parser is left with free type variables that we fill ... 

   eol :: GenParser Char st Char

   means: stream is Char  
          user state type is st (not used)
          underlying monad: Char
          return type: not defined and ... tbd? or *is* defined by the types within 
            the body of the eol function?

  if I was to guess, the reason we can't do something like: 
    string "foo"
    - is because the compiler has no idea what our stream, state, underlying monad and
      return type is/will be. 
    - and the key is that wrapping the primitives up with GenParsers supplies all of that
      missing type information. 

*extremely well written* blog post about typeable: http://chrisdone.com/posts/data-typeable

http://chrisdone.com/posts/fast-haskell-c-parsing-xml
http://www.serpentine.com/criterion/

9/7/2017

*YouCanDoThis> :show modules
YouCanDoThis     ( C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv3.hs, interpreted )
*YouCanDoThis> x <- return 42
*YouCanDoThis> x
42
*YouCanDoThis> :browse System.IO
... 
*YouCanDoThis> :t openFile

<interactive>:1:1: error: Variable not in scope: openFile
*YouCanDoThis> :t System.IO.openFile
System.IO.openFile
  :: FilePath
     -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
<interactive>:17:54: error:
    Data constructor not in scope: ReadMode :: GHC.IO.IOMode.IOMode
*YouCanDoThis> x <- System.IO.openFile "..\\thingsToParse\\example.bond" System.IO.ReadMode
*YouCanDoThis> x
{handle: ..\thingsToParse\example.bond}
*YouCanDoThis> import System.IO
*YouCanDoThis System.IO> y <- openFile "..\\thingsToParse\\example.bond" ReadMode
*YouCanDoThis System.IO> y
{handle: ..\thingsToParse\example.bond}
------------

Briefly see if we can add forwarding items to the ParserCombinators docs. 
Then get back to learning about parsec generally. 

Ran into this trying to get 'stack haddock --open' to do anything: 
  (https://github.com/commercialhaskell/stack/issues/1396)

  c:\Users\brodyb\Documents\GitHub\parsec>stack init
  Looking for .cabal or package.yaml files to use to init the project.
  Using cabal packages:
  - parsec.cabal

  Selecting the best among 11 snapshots...

  Downloaded lts-9.3 build plan.
  Selected mirror https://s3.amazonaws.com/hackage.fpcomplete.com/
  Downloading timestamp
  Downloading snapshot
  Updating index
  Updated package list downloaded
  Populated index cache.
  * Partially matches lts-9.3
      HUnit version 1.5.0.0 found
          - parsec requires >=1.2 && <1.4

  Downloaded nightly-2017-09-07 build plan.
  Unable to parse cabal file: FromString "This package requires at least Cabal version 2.0" Nothing

I can't get anything to work with stack, stack init, stack haddock --open or anything with 
parsec. It's a confusing, demoralizing waste of time. Back to working with things that I can 
actually grapple :-)



8/31/2017

Am noticing that I can get complicated compile time errors that are really 
just due to inconsistent columns in do-blocks. 

fooOption3 :: GenParser Char st Char
fooOption3 = 
    do char 'a'
        char 'b' <|> return 'a'

Note the inconsistent column for 'do char' vs. 'char' on next block

This is made worse by Code's auto-indenting rules during copy/paste. You can
start with working code, paste it and it'll be broken by auto-indent. 

GenParser: http://hackage.haskell.org/package/parsec-3.1.11/docs/src/Text.Parsec.String.html#GenParser

how does do know we're working in the 
ParsecT monad?
How does one work with things like this
and any other value as a parameter?
myTest2 :: GenParser Char st Char -> Char
myTest2 c =
    do char 'a'
       char 'b' <|> return 'a' 

If you look at this doc: http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-ParserCombinators-Parsec-Prim.html#t:GenParser

I think the reason myTest2 fails to compile is because it's not a thing that 
parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a

can understand. Right? So parse requires a Parsec s () a, while we're defining another
thing entirely with myTest2

So who's complaining here? I'd have thought it was parse complaining about the 
signature of myTest2 not being a Parsec but apparently not?

Here's the error: 

Prelude> :l src\csv3.hs
[1 of 1] Compiling Main             ( src\csv3.hs, interpreted )

src\csv3.hs:37:8: error:
    * Couldn't match expected type `Char'
                  with actual type `Text.Parsec.Prim.ParsecT s0 u0 m0 Char'
    * In a stmt of a 'do' block: char 'a'
      In the expression:
        do { char 'a';
             char 'b' <|> return 'a' }
      In an equation for `myTest2':
          myTest2 c
            = do { char 'a';
                   char 'b' <|> return 'a' }
Failed, modules loaded: none.

So maybe the question is not how to make myTest2 take a parameter but 
rather make GenParser by parameters. Right now our GenParser is totally
static wrt parameters. What varies is the input from parser. 

8/30/2017

Ok, one thing that's confused me is that when I examine documentation on hackage
for the module at the top of the file I don't see functions I know I am using in
the source file. 

Example: 
  This is a module: Text.ParserCombinators.Parsec
  And this is the hackage doc: https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-ParserCombinators-Parsec.html

But on that page, there's no "string" functions
BUT, the modules listed at the top contain that function, (the third one belatedly)
So how would I have found out the third module had this function and gone there more directly?

Try :t in ghci?

*Main> :t string
string
  :: Text.Parsec.Prim.Stream s m Char =>
     String -> Text.Parsec.Prim.ParsecT s u m String

ha! :info!!!

*Main> :show imports
:module +*Main -- added automatically
*Main> :info string
string ::
  Text.Parsec.Prim.Stream s m Char =>
  String -> Text.Parsec.Prim.ParsecT s u m String
        -- Defined in `Text.Parsec.Char'

How to call eol?

*Main> :info parse
parse ::
  Text.Parsec.Prim.Stream s Data.Functor.Identity.Identity t =>
  Text.Parsec.Prim.Parsec s () a
  -> SourceName -> s -> Either ParseError a
        -- Defined in `Text.Parsec.Prim'
*Main> parse eol "" "\n"
Right "\n"

How to show functions loaded in function: (super cool)

Prelude> :l csv3.hs
[1 of 1] Compiling Main             ( csv3.hs, interpreted )
Ok, modules loaded: Main.
*Main> :browse
eol :: GenParser Char st [Char]
eol2 :: GenParser Char st [Char]

8/25/2017 

PR merged!!!

parse cells "(unknown)" "foo"
Working with csv1.hs in order to: 
1. understand more about Parsec
2. understand more about why the example does "cells" 
   rather than "many cell"
3. working with csv1.hs in ghci *incrementally* which 
   means working with tinier pieces of the code than 
   parseCSV

   ex. parse cells "(unknown)" "foo"
   need a helper for that... 

Success! Two helpers: 

p1 :: GenParser Char () [String] -> String -> Either ParseError [String]
p1 x input = parse x "(unknown)" input 

p2 :: GenParser Char () [[String]] -> String -> Either ParseError [[String]]
p2 x input = parse x "(unknown)" input 

example usage: 

*Csv1> p1 line "foo\n"
Right ["foo"]
*Csv1> p2 csvFile "foo\n"
Right [["foo"]]

Added this: 

csvFile' :: GenParser Char st [[String]]
csvFile' = 
    do 
        result <- many line2
        eof
        return result

line2 :: GenParser Char st [String]
line2 = 
    do 
        result <- many cellContent
        eol 
        return result

which was to answer my question of why you can't just do "many cellContent": 

*Csv1> p1 line2 "foo\n"
*** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.


8/24/2017

SENT A PR: for the broken parsec example: https://github.com/haskell/parsec/pull/76

stack new csv1 simple
stack setup --install-ghc

After I ran this it said this, which might be useful for not running this
slow command every time I want to ty some code: 

  GHC installed to C:\Users\brodyb\AppData\Local\Programs\stack\x86_64-windows\ghc-8.0.2\
  stack will use a sandboxed GHC it installed
  For more information on paths, see 'stack path' and 'stack exec env'
  To use this GHC and packages outside of a project, consider using:
  stack ghc, stack ghci, stack runghc, or stack exec

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:22:14: error:
      parse error on input `<-'
      Perhaps this statement should be within a 'do' block?

  Fix: put all lines in each do block that used <- on
    the exact same column

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:5:1: error:
      Failed to load interface for `Text.ParserCombinators.Parsec'
      Perhaps you meant
        Text.ParserCombinators.ReadPrec (from base-4.9.1.0)
        Text.ParserCombinators.ReadP (from base-4.9.1.0)
      Use -v to see a list of the files searched for.

  Fix: added parsec to csv.cabal 

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  mtl-2.2.1: configure
  mtl-2.2.1: build
  text-1.2.2.2: configure
  text-1.2.2.2: build
  mtl-2.2.1: copy/register
  text-1.2.2.2: copy/register
  parsec-3.1.11: configure
  parsec-3.1.11: build
  parsec-3.1.11: copy/register
  csv1-0.1.0.0: configure (exe)
  Configuring csv1-0.1.0.0...
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:33:16: error:
      * Expecting one more argument to `GenParser Char String'
        Expected a type, but `GenParser Char String' has kind `* -> *'
      * In the type signature:
          cellContent :: GenParser Char String
  Completed 4 action(s).

  Fix: 
    Changed this: cellContent :: GenParser Char String
    To      this: cellContent :: GenParser Char st String

Then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  csv1-0.1.0.0: configure (exe)
  Configuring csv1-0.1.0.0...
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )
  [2 of 2] Compiling Main             ( src\Main.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Main.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs:7:3: error:
      * Couldn't match type `Either Text.Parsec.Error.ParseError'
                      with `IO'
        Expected type: IO [[String]]
          Actual type: Either Text.Parsec.Error.ParseError [[String]]
      * In a stmt of a 'do' block: parseCSV "hi\n"
        In the expression:
          do { parseCSV "hi\n";
              putStrLn "hello world" }
        In an equation for `main':
            main
              = do { parseCSV "hi\n";
                    putStrLn "hello world" }

  Fix: added this to main: 

    case (parseCSV "hi\n") of 
      Left msg -> putStrLn msg
      Right output -> putStrLn output

  but even then: 

    C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs:9:30: error:
      * Couldn't match type `[String]' with `Char'
        Expected type: String
          Actual type: [[String]]
      * In the first argument of `putStrLn', namely `output'
        In the expression: putStrLn output
        In a case alternative: Right output -> putStrLn output

  Fix?
    The [[String]] problem is real of course
    For now I'm doing this: stack ghci src/csv1.hs

(stack.cabal builds everything in src/) add csv1.hs to that?
stack build that?
stack ghci that?


8/23/2017

What are the functions?
From which libraries are they from?
Read those docs
Play with them in the repl

type Parser a = ParsecT String Symbols (ReaderT Environment IO) a

Loaded Text.Parsec into ghci but the first example from 
here: https://hackage.haskell.org/package/parsec
gives: 

Prelude Text.Parsec> let parenSet = char '(' >> many parenSet >> char ')'

<interactive>:9:5:
    Non type-variable argument in the constraint: Stream s m Char
    (Use FlexibleContexts to permit this)
    When checking that `parenSet' has the inferred type
      parenSet :: forall s u (m :: * -> *).
                  Stream s m Char =>
                  ParsecT s u m Char

Found and commented on the bug for the above: https://github.com/haskell/parsec/issues/56

And the bug report has the fix: let parenSet = char '(' >> many parenSet >> char ')' :: Parsec String () Char
It'd be interesting when I have time to think about why that's the fix from a type perspective and the error message. 

8/19/2017

Made a failing syntax test for view_of in 438_
Switched to 438_t so I can: 
	- add parseSimple
	- see what the other tests do when they fail with a natural parse 

*Main> :load IO
[1 of 1] Compiling IO               ( IO.hs, interpreted )
Ok, modules loaded: IO.
*IO> :t parseSimple

ok: 

*IO> parseSimple "tests/schema/error/view_of_nothing.bond"
Bond {bondImports = [], bondNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], bondDeclarations = [Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "SomeStruct", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 0, fieldModifier = Optional, fieldType = BT_String, fieldName = "F1", fieldDefault = Nothing},Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]},Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "DubiousView", declParams = [], structBase = Nothing, structFields = []}]}

so, since this parses, THAT'S the bug, so we'll fix it to not parse...

I learned that if I 'stack ghci' it'll pull in Language.Bond.Parser which we can :browse
not sure how to get that type signature though for parseBond
point isn't to use parseSimple or even parseBondFile, point is to slim the call stack to the point 
where I can figure out the fix

parseSimple "tests/schema/error/view_of_nothing.bond"
parseBondFile [] "tests/schema/error/view_of_nothing.bond"
:t parseBond
parseBond
  :: Text.Parsec.Pos.SourceName
     -> String
     -> FilePath
     -> ImportResolver
     -> IO (Either Text.Parsec.Error.ParseError Bond)

-- 212
-- struct view parser
view :: Parser Declaration
view = do
    attr <- attributes
    name <- keyword "struct" *> identifier <?> "struct view definition"
    decl <- keyword "view_of" *> qualifiedName >>= findStruct
    fields <- braces $ semiOrCommaSepEnd1 identifier
    namespaces <- asks currentNamespaces
    Struct namespaces attr name (declParams decl) (structBase decl) (viewFields decl fields) <$ optional semi
  where
    viewFields Struct {..} fields = filter ((`elem` fields) . fieldName) structFields
    viewFields _           _      = error "view/viewFields: impossible happened."

-- 160
findStruct :: QualifiedName -> Parser Declaration
findStruct name = doFind <?> "qualified struct name"
  where
    doFind = do
        symb <- findSymbol name
        case symb of
            Struct {..} -> return symb
            _ -> fail $ "The " ++ showPretty symb ++ " is invalid in this context. Expected a struct."

Took these notes: 

-- struct view parser
view :: Parser Declaration
view = do
    attr <- attributes
    name <- keyword "struct" *> identifier <?> "struct view definition"
    -- this tells us what we're viewing
    decl <- keyword "view_of" *> qualifiedName >>= findStruct
    -- and this says what in what we're viewing we wish to view
    fields <- braces $ semiOrCommaSepEnd1 identifier
    -- so at this point we can ask: are (all? some?) fields in the viewed struct?
    namespaces <- asks currentNamespaces
    Struct namespaces attr name (declParams decl) (structBase decl) (viewFields decl fields) <$ optional semi
  where
    viewFields Struct {..} fields = filter ((`elem` fields) . fieldName) structFields
    viewFields _           _      = error "view/viewFields: impossible happened."


8/18/2017

trying to update my .ghci config and get it to load from %userprofile%
contents: :set prompt "\x03BB: "
Command to run ghci with test symbols: stack ghci --test --main-is gbc-tests
This might be even better: stack ghci tests\TestMain.hs
	- smaller build
	- good modules list
	- less in the prompt (why though?)

Parsing a file directly in ghci: 

stack ghci tests\TestMain.hs
parseFile [] "tests/schema/value_of.bond"

*Main IO System.IO System.Directory> parseFile [] "tests/schema/value_of.bond"
Bond {bondImports = [], bondNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], bondDeclarations = [Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "SomeStruct", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 0, fieldModifier = Optional, fieldType = BT_String, fieldName = "F1", fieldDefault = Nothing},Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]},Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "ValidView", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]}]}

added "parseSimple"
IO.parseSimple "tests/schema/value_of.bond"

NEXT: Syntax.hs has a "failBadSyntax" which we need to use 
to create a test for the struct that should fail value_of. Check that out! 
