9/7/2017

*YouCanDoThis> :show modules
YouCanDoThis     ( C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv3.hs, interpreted )
*YouCanDoThis> x <- return 42
*YouCanDoThis> x
42
*YouCanDoThis> :browse System.IO
... 
*YouCanDoThis> :t openFile

<interactive>:1:1: error: Variable not in scope: openFile
*YouCanDoThis> :t System.IO.openFile
System.IO.openFile
  :: FilePath
     -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
<interactive>:17:54: error:
    Data constructor not in scope: ReadMode :: GHC.IO.IOMode.IOMode
*YouCanDoThis> x <- System.IO.openFile "..\\thingsToParse\\example.bond" System.IO.ReadMode
*YouCanDoThis> x
{handle: ..\thingsToParse\example.bond}
*YouCanDoThis> import System.IO
*YouCanDoThis System.IO> y <- openFile "..\\thingsToParse\\example.bond" ReadMode
*YouCanDoThis System.IO> y
{handle: ..\thingsToParse\example.bond}
------------

Briefly see if we can add forwarding items to the ParserCombinators docs. 
Then get back to learning about parsec generally. 

Ran into this trying to get 'stack haddock --open' to do anything: 
  (https://github.com/commercialhaskell/stack/issues/1396)

  c:\Users\brodyb\Documents\GitHub\parsec>stack init
  Looking for .cabal or package.yaml files to use to init the project.
  Using cabal packages:
  - parsec.cabal

  Selecting the best among 11 snapshots...

  Downloaded lts-9.3 build plan.
  Selected mirror https://s3.amazonaws.com/hackage.fpcomplete.com/
  Downloading timestamp
  Downloading snapshot
  Updating index
  Updated package list downloaded
  Populated index cache.
  * Partially matches lts-9.3
      HUnit version 1.5.0.0 found
          - parsec requires >=1.2 && <1.4

  Downloaded nightly-2017-09-07 build plan.
  Unable to parse cabal file: FromString "This package requires at least Cabal version 2.0" Nothing

I can't get anything to work with stack, stack init, stack haddock --open or anything with 
parsec. It's a confusing, demoralizing waste of time. Back to working with things that I can 
actually grapple :-)



8/31/2017

Am noticing that I can get complicated compile time errors that are really 
just due to inconsistent columns in do-blocks. 

fooOption3 :: GenParser Char st Char
fooOption3 = 
    do char 'a'
        char 'b' <|> return 'a'

Note the inconsistent column for 'do char' vs. 'char' on next block

This is made worse by Code's auto-indenting rules during copy/paste. You can
start with working code, paste it and it'll be broken by auto-indent. 

GenParser: http://hackage.haskell.org/package/parsec-3.1.11/docs/src/Text.Parsec.String.html#GenParser

how does do know we're working in the 
ParsecT monad?
How does one work with things like this
and any other value as a parameter?
myTest2 :: GenParser Char st Char -> Char
myTest2 c =
    do char 'a'
       char 'b' <|> return 'a' 

If you look at this doc: http://hackage.haskell.org/package/parsec-3.1.11/docs/Text-ParserCombinators-Parsec-Prim.html#t:GenParser

I think the reason myTest2 fails to compile is because it's not a thing that 
parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a

can understand. Right? So parse requires a Parsec s () a, while we're defining another
thing entirely with myTest2

So who's complaining here? I'd have thought it was parse complaining about the 
signature of myTest2 not being a Parsec but apparently not?

Here's the error: 

Prelude> :l src\csv3.hs
[1 of 1] Compiling Main             ( src\csv3.hs, interpreted )

src\csv3.hs:37:8: error:
    * Couldn't match expected type `Char'
                  with actual type `Text.Parsec.Prim.ParsecT s0 u0 m0 Char'
    * In a stmt of a 'do' block: char 'a'
      In the expression:
        do { char 'a';
             char 'b' <|> return 'a' }
      In an equation for `myTest2':
          myTest2 c
            = do { char 'a';
                   char 'b' <|> return 'a' }
Failed, modules loaded: none.

So maybe the question is not how to make myTest2 take a parameter but 
rather make GenParser by parameters. Right now our GenParser is totally
static wrt parameters. What varies is the input from parser. 

8/30/2017

Ok, one thing that's confused me is that when I examine documentation on hackage
for the module at the top of the file I don't see functions I know I am using in
the source file. 

Example: 
  This is a module: Text.ParserCombinators.Parsec
  And this is the hackage doc: https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-ParserCombinators-Parsec.html

But on that page, there's no "string" functions
BUT, the modules listed at the top contain that function, (the third one belatedly)
So how would I have found out the third module had this function and gone there more directly?

Try :t in ghci?

*Main> :t string
string
  :: Text.Parsec.Prim.Stream s m Char =>
     String -> Text.Parsec.Prim.ParsecT s u m String

ha! :info!!!

*Main> :show imports
:module +*Main -- added automatically
*Main> :info string
string ::
  Text.Parsec.Prim.Stream s m Char =>
  String -> Text.Parsec.Prim.ParsecT s u m String
        -- Defined in `Text.Parsec.Char'

How to call eol?

*Main> :info parse
parse ::
  Text.Parsec.Prim.Stream s Data.Functor.Identity.Identity t =>
  Text.Parsec.Prim.Parsec s () a
  -> SourceName -> s -> Either ParseError a
        -- Defined in `Text.Parsec.Prim'
*Main> parse eol "" "\n"
Right "\n"

How to show functions loaded in function: (super cool)

Prelude> :l csv3.hs
[1 of 1] Compiling Main             ( csv3.hs, interpreted )
Ok, modules loaded: Main.
*Main> :browse
eol :: GenParser Char st [Char]
eol2 :: GenParser Char st [Char]

8/25/2017 

PR merged!!!

parse cells "(unknown)" "foo"
Working with csv1.hs in order to: 
1. understand more about Parsec
2. understand more about why the example does "cells" 
   rather than "many cell"
3. working with csv1.hs in ghci *incrementally* which 
   means working with tinier pieces of the code than 
   parseCSV

   ex. parse cells "(unknown)" "foo"
   need a helper for that... 

Success! Two helpers: 

p1 :: GenParser Char () [String] -> String -> Either ParseError [String]
p1 x input = parse x "(unknown)" input 

p2 :: GenParser Char () [[String]] -> String -> Either ParseError [[String]]
p2 x input = parse x "(unknown)" input 

example usage: 

*Csv1> p1 line "foo\n"
Right ["foo"]
*Csv1> p2 csvFile "foo\n"
Right [["foo"]]

Added this: 

csvFile' :: GenParser Char st [[String]]
csvFile' = 
    do 
        result <- many line2
        eof
        return result

line2 :: GenParser Char st [String]
line2 = 
    do 
        result <- many cellContent
        eol 
        return result

which was to answer my question of why you can't just do "many cellContent": 

*Csv1> p1 line2 "foo\n"
*** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.


8/24/2017

SENT A PR: for the broken parsec example: https://github.com/haskell/parsec/pull/76

stack new csv1 simple
stack setup --install-ghc

After I ran this it said this, which might be useful for not running this
slow command every time I want to ty some code: 

  GHC installed to C:\Users\brodyb\AppData\Local\Programs\stack\x86_64-windows\ghc-8.0.2\
  stack will use a sandboxed GHC it installed
  For more information on paths, see 'stack path' and 'stack exec env'
  To use this GHC and packages outside of a project, consider using:
  stack ghc, stack ghci, stack runghc, or stack exec

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:22:14: error:
      parse error on input `<-'
      Perhaps this statement should be within a 'do' block?

  Fix: put all lines in each do block that used <- on
    the exact same column

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:5:1: error:
      Failed to load interface for `Text.ParserCombinators.Parsec'
      Perhaps you meant
        Text.ParserCombinators.ReadPrec (from base-4.9.1.0)
        Text.ParserCombinators.ReadP (from base-4.9.1.0)
      Use -v to see a list of the files searched for.

  Fix: added parsec to csv.cabal 

and then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  mtl-2.2.1: configure
  mtl-2.2.1: build
  text-1.2.2.2: configure
  text-1.2.2.2: build
  mtl-2.2.1: copy/register
  text-1.2.2.2: copy/register
  parsec-3.1.11: configure
  parsec-3.1.11: build
  parsec-3.1.11: copy/register
  csv1-0.1.0.0: configure (exe)
  Configuring csv1-0.1.0.0...
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\csv1.hs:33:16: error:
      * Expecting one more argument to `GenParser Char String'
        Expected a type, but `GenParser Char String' has kind `* -> *'
      * In the type signature:
          cellContent :: GenParser Char String
  Completed 4 action(s).

  Fix: 
    Changed this: cellContent :: GenParser Char String
    To      this: cellContent :: GenParser Char st String

Then?

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1>stack build
  csv1-0.1.0.0: configure (exe)
  Configuring csv1-0.1.0.0...
  csv1-0.1.0.0: build (exe)
  Preprocessing executable 'csv1' for csv1-0.1.0.0...
  [1 of 2] Compiling Csv1             ( src\Csv1.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Csv1.o )
  [2 of 2] Compiling Main             ( src\Main.hs, .stack-work\dist\ca59d0ab\build\csv1\csv1-tmp\Main.o )

  C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs:7:3: error:
      * Couldn't match type `Either Text.Parsec.Error.ParseError'
                      with `IO'
        Expected type: IO [[String]]
          Actual type: Either Text.Parsec.Error.ParseError [[String]]
      * In a stmt of a 'do' block: parseCSV "hi\n"
        In the expression:
          do { parseCSV "hi\n";
              putStrLn "hello world" }
        In an equation for `main':
            main
              = do { parseCSV "hi\n";
                    putStrLn "hello world" }

  Fix: added this to main: 

    case (parseCSV "hi\n") of 
      Left msg -> putStrLn msg
      Right output -> putStrLn output

  but even then: 

    C:\Users\brodyb\Documents\GitHub\Notes\csv\csv1\src\Main.hs:9:30: error:
      * Couldn't match type `[String]' with `Char'
        Expected type: String
          Actual type: [[String]]
      * In the first argument of `putStrLn', namely `output'
        In the expression: putStrLn output
        In a case alternative: Right output -> putStrLn output

  Fix?
    The [[String]] problem is real of course
    For now I'm doing this: stack ghci src/csv1.hs

(stack.cabal builds everything in src/) add csv1.hs to that?
stack build that?
stack ghci that?


8/23/2017

What are the functions?
From which libraries are they from?
Read those docs
Play with them in the repl

type Parser a = ParsecT String Symbols (ReaderT Environment IO) a

Loaded Text.Parsec into ghci but the first example from 
here: https://hackage.haskell.org/package/parsec
gives: 

Prelude Text.Parsec> let parenSet = char '(' >> many parenSet >> char ')'

<interactive>:9:5:
    Non type-variable argument in the constraint: Stream s m Char
    (Use FlexibleContexts to permit this)
    When checking that `parenSet' has the inferred type
      parenSet :: forall s u (m :: * -> *).
                  Stream s m Char =>
                  ParsecT s u m Char

Found and commented on the bug for the above: https://github.com/haskell/parsec/issues/56

And the bug report has the fix: let parenSet = char '(' >> many parenSet >> char ')' :: Parsec String () Char
It'd be interesting when I have time to think about why that's the fix from a type perspective and the error message. 

8/19/2017

Made a failing syntax test for view_of in 438_
Switched to 438_t so I can: 
	- add parseSimple
	- see what the other tests do when they fail with a natural parse 

*Main> :load IO
[1 of 1] Compiling IO               ( IO.hs, interpreted )
Ok, modules loaded: IO.
*IO> :t parseSimple

ok: 

*IO> parseSimple "tests/schema/error/view_of_nothing.bond"
Bond {bondImports = [], bondNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], bondDeclarations = [Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "SomeStruct", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 0, fieldModifier = Optional, fieldType = BT_String, fieldName = "F1", fieldDefault = Nothing},Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]},Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "DubiousView", declParams = [], structBase = Nothing, structFields = []}]}

so, since this parses, THAT'S the bug, so we'll fix it to not parse...

I learned that if I 'stack ghci' it'll pull in Language.Bond.Parser which we can :browse
not sure how to get that type signature though for parseBond
point isn't to use parseSimple or even parseBondFile, point is to slim the call stack to the point 
where I can figure out the fix

parseSimple "tests/schema/error/view_of_nothing.bond"
parseBondFile [] "tests/schema/error/view_of_nothing.bond"
:t parseBond
parseBond
  :: Text.Parsec.Pos.SourceName
     -> String
     -> FilePath
     -> ImportResolver
     -> IO (Either Text.Parsec.Error.ParseError Bond)

-- 212
-- struct view parser
view :: Parser Declaration
view = do
    attr <- attributes
    name <- keyword "struct" *> identifier <?> "struct view definition"
    decl <- keyword "view_of" *> qualifiedName >>= findStruct
    fields <- braces $ semiOrCommaSepEnd1 identifier
    namespaces <- asks currentNamespaces
    Struct namespaces attr name (declParams decl) (structBase decl) (viewFields decl fields) <$ optional semi
  where
    viewFields Struct {..} fields = filter ((`elem` fields) . fieldName) structFields
    viewFields _           _      = error "view/viewFields: impossible happened."

-- 160
findStruct :: QualifiedName -> Parser Declaration
findStruct name = doFind <?> "qualified struct name"
  where
    doFind = do
        symb <- findSymbol name
        case symb of
            Struct {..} -> return symb
            _ -> fail $ "The " ++ showPretty symb ++ " is invalid in this context. Expected a struct."

Took these notes: 

-- struct view parser
view :: Parser Declaration
view = do
    attr <- attributes
    name <- keyword "struct" *> identifier <?> "struct view definition"
    -- this tells us what we're viewing
    decl <- keyword "view_of" *> qualifiedName >>= findStruct
    -- and this says what in what we're viewing we wish to view
    fields <- braces $ semiOrCommaSepEnd1 identifier
    -- so at this point we can ask: are (all? some?) fields in the viewed struct?
    namespaces <- asks currentNamespaces
    Struct namespaces attr name (declParams decl) (structBase decl) (viewFields decl fields) <$ optional semi
  where
    viewFields Struct {..} fields = filter ((`elem` fields) . fieldName) structFields
    viewFields _           _      = error "view/viewFields: impossible happened."


8/18/2017

trying to update my .ghci config and get it to load from %userprofile%
contents: :set prompt "\x03BB: "
Command to run ghci with test symbols: stack ghci --test --main-is gbc-tests
This might be even better: stack ghci tests\TestMain.hs
	- smaller build
	- good modules list
	- less in the prompt (why though?)

Parsing a file directly in ghci: 

stack ghci tests\TestMain.hs
parseFile [] "tests/schema/value_of.bond"

*Main IO System.IO System.Directory> parseFile [] "tests/schema/value_of.bond"
Bond {bondImports = [], bondNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], bondDeclarations = [Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "SomeStruct", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 0, fieldModifier = Optional, fieldType = BT_String, fieldName = "F1", fieldDefault = Nothing},Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]},Struct {declNamespaces = [Namespace {nsLanguage = Nothing, nsName = ["view_not_there"]}], declAttributes = [], declName = "ValidView", declParams = [], structBase = Nothing, structFields = [Field {fieldAttributes = [], fieldOrdinal = 1, fieldModifier = Optional, fieldType = BT_String, fieldName = "F2", fieldDefault = Nothing}]}]}

added "parseSimple"
IO.parseSimple "tests/schema/value_of.bond"

NEXT: Syntax.hs has a "failBadSyntax" which we need to use 
to create a test for the struct that should fail value_of. Check that out! 