-- Haskell Playground 1.0
--build "a"
--build "ab"
--
--
--build "abc"
--
--
--
--build "abcd"
--
----quickCheck prop_buildCount
--
--build x
--
--(V.init (V.fromList "a"))
y = "GATTACA"
--
--reverse [r | r <- [0..(length x)]]
--
--[l | l <- [0..(length x)]]
--
--take 5 
--  [ 
--    [ (l,r) | l <- [0..(length x)] ] 
--            | r <- [1..] 
--  ]
--  

--[30,29..0]

--[(i,j) | i <- [1..6],
--         j <- [6,5..1] ]
--         
--[ [ (i,j) | i <- [1..6] ] | j <- [6,5..1] ]
--
--
--
--[ [ (i,j) | i <- [1..6], i /= j ] | j <- [6,5..1] ]


--length $ concat [ [ (i,j) | i <- [1..6], i < j ] | j <- [6,5..1] ]
--
z = concat [ [ (l,r) | l <- [0..(length y)], l < r ] | r <- [(length y),((length y) - 1)..1] ]
z
length z
-- now, given 
-- a map from 0 to (n * (n + 1)) `div` 2
-- where n is length str
-- we can index into z to get slices
-- for all possible substrings of str
-- linearly with no recursion


x = [(0, 6), (0, 5), (0, 4), (0, 3), (0, 2), (0, 1), (1, 6), (1, 5), (1, 4), (1, 3), (1, 2),(2, 6), (2, 5), (2, 4), (2, 3), (3, 6), (3, 5),(3, 4),(4, 6),(4, 5),(5, 6)]


length x

subCount $ length y


















