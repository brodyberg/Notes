-- Haskell Playground 1.0
y = "GATTACA"
y' = subCount $ length y
y'

xk = "foo"

-- so theoretically we shouldn't need this if we pull from the previous computation along with index
-- straight into the source string
foldr (\item (subStr, l, r, ix) -> if (ix >= l && ix <= r) then (item : subStr, l, r, ix + 1)  else (subStr, l, r, ix + 1)) ("", 2, 4, 0) y



maker "a"
maker "ab"
x = "foo"


-- one by one, knock tail off
-- knock head off
-- one by one, knock tail off
-- until there's no more list


-- l is 0
-- r is length - 1
-- head is at l, remove tail (length - 1) times | length is 
-- head is at 1, remove tail (length - 1) times




-- START

-- length is length

-- l is 0
-- r is length - 1
-- list of results is set to [string]
-- ix into list of results is 1 (representing we're now past that step)

-- LOOP

-- grab previous string: results !! (ix - 1) 

-- if l == length - 1
--   return results

-- if l == r
--   l + 1
--   r is length - 1
--   REPEAT
-- else
--   r - 1
--   REPEAT

--maker :: String -> [String]
--maker str = construct len 0 (len - 1) [str] 1
--  where 
--    len = length str    
--
--               --length l      r      results     ix
--    construct :: Int -> Int -> Int -> [String] -> Int -> [String]
--    construct len l r results ix = 
--      if l == (len - 1)
--      then results
--      else if (l == r)
--        then construct len (l + 1) (len - 1) results' (ix + 1)
--      else
--        construct len l (r + 1) results' (ix + 1)
--        
--      where 
--        results' :: [String]
--        results' = (results !! (ix - 1)) : results 
    






















-- l /= r to drop last item
-- r - 1






-- head is at l, remove tail until r == l
-- bump l by 1






















-- head is at 1, remove tail (length - 1) times




s :: String -> [String]
s str = run str []
  where
    run str [] = run str [str] 
    run str (x:xs) =  


-- just do this and then reverse the output 
-- so rather than counting from nothing we're counting
-- from maximum?
slices = [(left,right) | left <- [1..(length y)],
                         right <- [(length y), ((length y) - 1) ..1]]

slices

length slices

slices' = [(left,right) | left <- [1..(length y)],
                          right <- [(length y), ((length y) - 1) ..1],
                          (left /= right)]

slices'

length slices'

--filter (\(l,r) -> ) slices'

y' = allSubstrings y
y'
length y'

slices_ = [(left,right) | left <- [1..(length y)],
                          right <- [(length y), ((length y) - 1) ..1],
                          (right > left)]

slices_

length slices_


slices''' = [(left,right) | left <- [1..(length y)],
                          right <- [(length y), ((length y) - 1) ..1],
                          (left /= right && right > left)]

slices'''

length slices'''

a



-- foldr (\i -> i) [] a

range 

-- make the slice list
-- cut up the array
-- print each piece paired with it's slice instruction

len = length y
len
slices'' = [ [ (l,r) | l <- [1..len] ] | 
                       r <- [len, (len - 1)..1] ]
                  
slices''
     
filter (\(l,r) -> l /= r) $ concat slices''

-- , (l /= r)
--take 5 [ [ (i,j) | i <- [1,2] ] | j <- [1..] ]

slices''

length slices''

subCount n = (n * (n + 1)) `div` 2

--x = "MSRVGKYPVEVPAGVQVSVADGFFKAKGKLGELTVPVSRHVEVKIEGSNVSVAPVGRRS"


-- WE'VE GOT THIS
-- we have two pointers, one to the left
-- edge, one to the right edge and we 
-- start the whole jam with the string 
-- itself

-- the string: GATTACA
-- G
-- 06
-- GA
-- 0 5
-- GAT
-- 0 4
-- GATT
-- 0  3
-- GATTA
-- 0   2
-- GATTAC
-- 0    1
-- GATTACA
-- 0     0
-- read up

--  A
--  1
--  AT
--  11
--  ATT
--  1 2
--  ATTA
--  1  3
--  ATTAC
--  1   4
--  ATTACA
--  1    5
-- read up
-- so the idea is: 
-- you put the whole string in to start
-- for line: 38
-- that means, the previous string
-- without the last item is our string
-- previous string without last item is our
-- string
-- left counts UP and reads RIGHT
--                    from head
-- right counts UP and reads LEFT
--                    from tail

--   T
--   TT
--   TTA
--   TTAC
--   TTACA
--    T
--    TA
--    TAC
--    TACA
--     A
--     AC
--     ACA
--      C
--      CA
--       A