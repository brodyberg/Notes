-- Haskell Playground 1.0
----buyable 10
----buyable 100
----buyable 1000
----buyable 10000
----buyable 100000000
-- :t (head "foo")
--
--"f" ++ []
--["f"] ++ ["o"]
--
--z = []
--z
--z' = z ++ ["x"]
--z'
--z'' = z' ++ ["y"]
--z''
--
--n = length x
--n
--l = (n * (n + 1)) `div` 2

y = "GATTACA"
y' = subCount $ length y
y'

xk = "foo"

foldr (\item (subStr, l, r, ix) -> if (ix >= l && ix <= r) then (item : subStr, l, r, ix + 1)  else (subStr, l, r, ix + 1)) ("", 2, 4, 0) y

-- just do this and then reverse the output 
-- so rather than counting from nothing we're counting
-- from maximum?
slices = [(left,right) | left <- [1..(length y)],
                         right <- [(length y), ((length y) - 1) ..1]]

slices

length slices

slices' = [(left,right) | left <- [1..(length y)],
                          right <- [(length y), ((length y) - 1) ..1],
                          (left /= right)]

slices'

length slices'

--filter (\(l,r) -> ) slices'

y' = allSubstrings y
y'
length y'

slices_ = [(left,right) | left <- [1..(length y)],
                          right <- [(length y), ((length y) - 1) ..1],
                          (right > left)]

slices_

length slices_


slices''' = [(left,right) | left <- [1..(length y)],
                          right <- [(length y), ((length y) - 1) ..1],
                          (left /= right && right > left)]

slices'''

length slices'''

a



-- foldr (\i -> i) [] a

range 

-- make the slice list
-- cut up the array
-- print each piece paired with it's slice instruction

len = length y
len
slices'' = [ [ (l,r) | l <- [1..len] ] | 
                       r <- [len, (len - 1)..1] ]
                  
slices''
     
filter (\(l,r) -> l /= r) $ concat slices''

-- , (l /= r)
--take 5 [ [ (i,j) | i <- [1,2] ] | j <- [1..] ]

slices''

length slices''

subCount n = (n * (n + 1)) `div` 2

--x = "MSRVGKYPVEVPAGVQVSVADGFFKAKGKLGELTVPVSRHVEVKIEGSNVSVAPVGRRS"


-- WE'VE GOT THIS
-- we have two pointers, one to the left
-- edge, one to the right edge and we 
-- start the whole jam with the string 
-- itself

-- the string: GATTACA
-- G
-- 06
-- GA
-- 0 5
-- GAT
-- 0 4
-- GATT
-- 0  3
-- GATTA
-- 0   2
-- GATTAC
-- 0    1
-- GATTACA
-- 0     0
-- read up

--  A
--  1
--  AT
--  11
--  ATT
--  1 2
--  ATTA
--  1  3
--  ATTAC
--  1   4
--  ATTACA
--  1    5
-- read up
-- so the idea is: 
-- you put the whole string in to start
-- for line: 38
-- that means, the previous string
-- without the last item is our string
-- previous string without last item is our
-- string
-- left counts UP and reads RIGHT
--                    from head
-- right counts UP and reads LEFT
--                    from tail

--   T
--   TT
--   TTA
--   TTAC
--   TTACA
--    T
--    TA
--    TAC
--    TACA
--     A
--     AC
--     ACA
--      C
--      CA
--       A